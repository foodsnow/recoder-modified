stdout: else_statement -> BlockStatement
using GPU
p
path org.apache.commons.lang.time.FastDateFormat
getDateInstance
Position(line=279, column=32)
FOUND IT!
path org.apache.commons.lang.time.FastDateFormat
getDateTimeInstance
Position(line=458, column=32)
FOUND IT!
[{'bugid': 'Lang-50', 'treeroot': <Searchnode.Node object at 0x7f6590cc0a10>, 'troot': <Searchnode.Node object at 0x7f6590cc0a10>, 'oldcode': '        if (locale != null) {', 'filepath': 'buggy/Lang-50/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'subroot': <Searchnode.Node object at 0x7f6590ccd1d0>, 'vardic': {'getDateInstance_ter': 'meth0', 'style_ter': 'par0', 'timeZone_ter': 'par1', 'locale_ter': 'par2', 'key_ter': 'loc0', 'format_ter': 'loc1', 'formatter_ter': 'loc2', 'pattern_ter': 'loc3'}, 'typedic': {'style_ter': 'int', 'timeZone_ter': 'TimeZone', 'locale_ter': 'Locale', 'key_ter': 'Object', 'format_ter': 'FastDateFormat', 'formatter_ter': 'SimpleDateFormat', 'pattern_ter': 'String'}, 'idss': 'Lang-50', 'classname': 'org.apache.commons.lang.time.FastDateFormat', 'precode': '/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang.Validate;\n\n/**\n * <p>FastDateFormat is a fast and thread-safe version of\n * {@link java.text.SimpleDateFormat}.</p>\n * \n * <p>This class can be used as a direct replacement to\n * <code>SimpleDateFormat</code> in most formatting situations.\n * This class is especially useful in multi-threaded server environments.\n * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n * nor will it be as Sun have closed the bug/RFE.\n * </p>\n *\n * <p>Only formatting is supported, but all patterns are compatible with\n * SimpleDateFormat (except time zones - see below).</p>\n *\n * <p>Java 1.4 introduced a new pattern letter, <code>\'Z\'</code>, to represent\n * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n * This pattern letter can be used here (on all JDK versions).</p>\n *\n * <p>In addition, the pattern <code>\'ZZ\'</code> has been made to represent\n * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n * This introduces a minor incompatibility with Java 1.4, but at a gain of\n * useful functionality.</p>\n *\n * @author TeaTrove project\n * @author Brian S O\'Neill\n * @author Sean Schofield\n * @author Gary Gregory\n * @author Stephen Colebourne\n * @author Nikolay Metchev\n * @since 2.0\n * @version $Id$\n */\npublic class FastDateFormat extends Format {\n    // A lot of the speed in this class comes from caching, but some comes\n    // from the special int to StringBuffer conversion.\n    //\n    // The following produces a padded 2 digit number:\n    //   buffer.append((char)(value / 10 + \'0\'));\n    //   buffer.append((char)(value % 10 + \'0\'));\n    //\n    // Note that the fastest append to StringBuffer is a single char (used here).\n    // Note that Integer.toString() is not called, the conversion is simply\n    // taking the value and adding (mathematically) the ASCII value for \'0\'.\n    // So, don\'t change this code! It works and is very fast.\n    \n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * FULL locale dependent date or time style.\n     */\n    public static final int FULL = DateFormat.FULL;\n    /**\n     * LONG locale dependent date or time style.\n     */\n    public static final int LONG = DateFormat.LONG;\n    /**\n     * MEDIUM locale dependent date or time style.\n     */\n    public static final int MEDIUM = DateFormat.MEDIUM;\n    /**\n     * SHORT locale dependent date or time style.\n     */\n    public static final int SHORT = DateFormat.SHORT;\n    \n    private static String cDefaultPattern;\n\n    private static Map cInstanceCache = new HashMap(7);\n    private static Map cDateInstanceCache = new HashMap(7);\n    private static Map cTimeInstanceCache = new HashMap(7);\n    private static Map cDateTimeInstanceCache = new HashMap(7);\n    private static Map cTimeZoneDisplayCache = new HashMap(7);\n\n    /**\n     * The pattern.\n     */\n    private final String mPattern;\n    /**\n     * The time zone.\n     */\n    private final TimeZone mTimeZone;\n    /**\n     * Whether the time zone overrides any on Calendars.\n     */\n    private final boolean mTimeZoneForced;\n    /**\n     * The locale.\n     */\n    private final Locale mLocale;\n    /**\n     * Whether the locale overrides the default.\n     */\n    private final boolean mLocaleForced;\n    /**\n     * The parsed rules.\n     */\n    private transient Rule[] mRules;\n    /**\n     * The estimated maximum length.\n     */\n    private transient int mMaxLengthEstimate;\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a formatter instance using the default pattern in the\n     * default locale.</p>\n     * \n     * @return a date/time formatter\n     */\n    public static FastDateFormat getInstance() {\n        return getInstance(getDefaultPattern(), null, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern in the\n     * default locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern) {\n        return getInstance(pattern, null, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern and\n     * time zone.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n        return getInstance(pattern, timeZone, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern and\n     * locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param locale  optional locale, overrides system locale\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern, Locale locale) {\n        return getInstance(pattern, null, locale);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern, time zone\n     * and locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     *  or <code>null</code>\n     */\n    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n        if (format == null) {\n            format = emptyFormat;\n            format.init();  // convert shell format into usable one\n            cInstanceCache.put(format, format);  // this is OK!\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a date formatter instance using the specified style in the\n     * default time zone and locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style) {\n        return getDateInstance(style, null, null);\n    }\n\n    /**\n     * <p>Gets a date formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style, Locale locale) {\n        return getDateInstance(style, null, locale);\n    }\n\n    /**\n     * <p>Gets a date formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n        return getDateInstance(style, timeZone, null);\n    }\n    /**\n     * <p>Gets a date formatter instance using the specified style, time\n     * zone and locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = new Integer(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n', 'aftercode': '            key = new Pair(key, locale);\n        }\n\n\n        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateInstanceCache.put(key, format);\n                \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a time formatter instance using the specified style in the\n     * default time zone and locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style) {\n        return getTimeInstance(style, null, null);\n    }\n\n    /**\n     * <p>Gets a time formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n        return getTimeInstance(style, null, locale);\n    }\n    \n    /**\n     * <p>Gets a time formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted time\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n        return getTimeInstance(style, timeZone, null);\n    }\n    \n    /**\n     * <p>Gets a time formatter instance using the specified style, time\n     * zone and locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted time\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = new Integer(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cTimeInstanceCache.put(key, format);\n            \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a date/time formatter instance using the specified style\n     * in the default time zone and locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle, Locale locale) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle, TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style,\n     * time zone and locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n            Locale locale) {\n\n        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                        locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateTimeInstanceCache.put(key, format);\n\n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date time pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the time zone display name, using a cache for performance.</p>\n     * \n     * @param tz  the zone to query\n     * @param daylight  true if daylight savings\n     * @param style  the style to use <code>TimeZone.LONG</code>\n     *  or <code>TimeZone.SHORT</code>\n     * @param locale  the locale to use\n     * @return the textual name of the time zone\n     */\n    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = (String) cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            // This is a very slow call, so cache the results.\n            value = tz.getDisplayName(daylight, style, locale);\n            cTimeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }\n\n    /**\n     * <p>Gets the default pattern.</p>\n     * \n     * @return the default pattern\n     */\n    private static synchronized String getDefaultPattern() {\n        if (cDefaultPattern == null) {\n            cDefaultPattern = new SimpleDateFormat().toPattern();\n        }\n        return cDefaultPattern;\n    }\n\n    // Constructor\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Constructs a new FastDateFormat.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  time zone to use, <code>null</code> means use\n     *  default for <code>Date</code> and value within for\n     *  <code>Calendar</code>\n     * @param locale  locale, <code>null</code> means use system\n     *  default\n     * @throws IllegalArgumentException if pattern is invalid or\n     *  <code>null</code>\n     */\n    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n        super();\n        if (pattern == null) {\n            throw new IllegalArgumentException("The pattern must not be null");\n        }\n        mPattern = pattern;\n        \n        mTimeZoneForced = (timeZone != null);\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        mTimeZone = timeZone;\n        \n        mLocaleForced = (locale != null);\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        mLocale = locale;\n    }\n\n    /**\n     * <p>Initializes the instance for first use.</p>\n     */\n    protected void init() {\n        List rulesList = parsePattern();\n        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    // Parse the pattern\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     * \n     * @return a <code>List</code> of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List rules = new ArrayList();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case \'G\': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case \'y\': // year (number)\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case \'M\': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case \'d\': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case \'h\': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case \'H\': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case \'m\': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case \'s\': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case \'S\': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case \'E\': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case \'D\': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case \'F\': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case \'w\': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case \'W\': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case \'a\': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case \'k\': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case \'K\': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case \'z\': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case \'Z\': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case \'\\\'\': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException("Illegal pattern component: " + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    /**\n     * <p>Performs the parsing of tokens.</p>\n     * \n     * @param pattern  the pattern\n     * @param indexRef  index references\n     * @return parsed token\n     */\n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuffer buf = new StringBuffer();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= \'A\' && c <= \'Z\' || c >= \'a\' && c <= \'z\') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append(\'\\\'\');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == \'\\\'\') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == \'\\\'\') {\n                        // \'\' is treated as escaped \'\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= \'A\' && c <= \'Z\' || c >= \'a\' && c <= \'z\')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    /**\n     * <p>Gets an appropriate rule for the padding required.</p>\n     * \n     * @param field  the field to get a rule for\n     * @param padding  the padding required\n     * @return a new rule with the correct padding\n     */\n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    // Format methods\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Formats a <code>Date</code>, <code>Calendar</code> or\n     * <code>Long</code> (milliseconds) object.</p>\n     * \n     * @param obj  the object to format\n     * @param toAppendTo  the buffer to append to\n     * @param pos  the position - ignored\n     * @return the buffer passed in\n     */\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException("Unknown class: " +\n                (obj == null ? "<null>" : obj.getClass().getName()));\n        }\n    }\n\n    /**\n     * <p>Formats a millisecond <code>long</code> value.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @return the formatted string\n     * @since 2.1\n     */\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object.</p>\n     * \n     * @param calendar  the calendar to format\n     * @return the formatted string\n     */\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a milliseond <code>long</code> value into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     * @since 2.1\n     */\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param date  the date to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n\n    /**\n     * <p>Performs the formatting by applying the rules to the\n     * specified calendar.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        Rule[] rules = mRules;\n        int len = mRules.length;\n        for (int i = 0; i < len; i++) {\n            rules[i].appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    // Parsing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parsing is not supported.</p>\n     * \n     * @param source  the string to parse\n     * @param pos  the parsing position\n     * @return <code>null</code> as not supported\n     */\n    public Object parseObject(String source, ParsePosition pos) {\n        pos.setIndex(0);\n        pos.setErrorIndex(0);\n        return null;\n    }\n    \n    // Accessors\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the pattern used by this formatter.</p>\n     * \n     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n     */\n    public String getPattern() {\n        return mPattern;\n    }\n\n    /**\n     * <p>Gets the time zone used by this formatter.</p>\n     *\n     * <p>This zone is always used for <code>Date</code> formatting.\n     * If a <code>Calendar</code> is passed in to be formatted, the\n     * time zone on that may be used depending on\n     * {@link #getTimeZoneOverridesCalendar()}.</p>\n     * \n     * @return the time zone\n     */\n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    /**\n     * <p>Returns <code>true</code> if the time zone of the\n     * calendar overrides the time zone of the formatter.</p>\n     * \n     * @return <code>true</code> if time zone of formatter\n     *  overridden for calendars\n     */\n    public boolean getTimeZoneOverridesCalendar() {\n        return mTimeZoneForced;\n    }\n\n    /**\n     * <p>Gets the locale used by this formatter.</p>\n     * \n     * @return the locale\n     */\n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    /**\n     * <p>Gets an estimate for the maximum string length that the\n     * formatter will produce.</p>\n     *\n     * <p>The actual formatted length will almost always be less than or\n     * equal to this amount.</p>\n     * \n     * @return the maximum formatted length\n     */\n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    // Basics\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Compares two objects for equality.</p>\n     * \n     * @param obj  the object to compare to\n     * @return <code>true</code> if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDateFormat == false) {\n            return false;\n        }\n        FastDateFormat other = (FastDateFormat) obj;\n        if (\n            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n            (mTimeZoneForced == other.mTimeZoneForced) &&\n            (mLocaleForced == other.mLocaleForced)\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Returns a hashcode compatible with equals.</p>\n     * \n     * @return a hashcode compatible with equals\n     */\n    public int hashCode() {\n        int total = 0;\n        total += mPattern.hashCode();\n        total += mTimeZone.hashCode();\n        total += (mTimeZoneForced ? 1 : 0);\n        total += mLocale.hashCode();\n        total += (mLocaleForced ? 1 : 0);\n        return total;\n    }\n\n    /**\n     * <p>Gets a debugging string version of this formatter.</p>\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        return "FastDateFormat[" + mPattern + "]";\n    }\n\n    // Serializing\n    //-----------------------------------------------------------------------\n    /**\n     * Create the object after serialization. This implementation reinitializes the \n     * transient properties.\n     *\n     * @param in ObjectInputStream from which the object is being deserialized.\n     * @throws IOException if there is an IO issue.\n     * @throws ClassNotFoundException if a class cannot be found.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n    \n    // Rules\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Inner class defining a rule.</p>\n     */\n    private interface Rule {\n        /**\n         * Returns the estimated lentgh of the result.\n         * \n         * @return the estimated length\n         */\n        int estimateLength();\n        \n        /**\n         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n         * \n         * @param buffer the output buffer\n         * @param calendar calendar to be appended\n         */\n        void appendTo(StringBuffer buffer, Calendar calendar);\n    }\n\n    /**\n     * <p>Inner class defining a numeric rule.</p>\n     */\n    private interface NumberRule extends Rule {\n        /**\n         * Appends the specified value to the output buffer based on the rule implementation.\n         * \n         * @param buffer the output buffer\n         * @param value the value to be appended\n         */\n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    /**\n     * <p>Inner class to output a constant single character.</p>\n     */\n    private static class CharacterLiteral implements Rule {\n        private final char mValue;\n\n        /**\n         * Constructs a new instance of <code>CharacterLiteral</code>\n         * to hold the specified value.\n         * \n         * @param value the character literal\n         */\n        CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    /**\n     * <p>Inner class to output a constant string.</p>\n     */\n    private static class StringLiteral implements Rule {\n        private final String mValue;\n\n        /**\n         * Constructs a new instance of <code>StringLiteral</code>\n         * to hold the specified value.\n         * \n         * @param value the string literal\n         */\n        StringLiteral(String value) {\n            mValue = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    /**\n     * <p>Inner class to output one of a set of values.</p>\n     */\n    private static class TextField implements Rule {\n        private final int mField;\n        private final String[] mValues;\n\n        /**\n         * Constructs an instance of <code>TextField</code>\n         * with the specified field and values.\n         * \n         * @param field the field\n         * @param values the field values\n         */\n        TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    /**\n     * <p>Inner class to output an unpadded number.</p>\n     */\n    private static class UnpaddedNumberField implements NumberRule {\n        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n        \n        private final int mField;\n\n        /**\n         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n         * \n         * @param field the field\n         */\n        UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 4;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + \'0\'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output an unpadded month.</p>\n     */\n    private static class UnpaddedMonthField implements NumberRule {\n        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n\n        /**\n         * Constructs an instance of <code>UnpaddedMonthField</code>.\n         *\n         */\n        UnpaddedMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + \'0\'));\n            } else {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a padded number.</p>\n     */\n    private static class PaddedNumberField implements NumberRule {\n        private final int mField;\n        private final int mSize;\n\n        /**\n         * Constructs an instance of <code>PaddedNumberField</code>.\n         * \n         * @param field the field\n         * @param size size of the output field\n         */\n        PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                // Should use UnpaddedNumberField or TwoDigitNumberField.\n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 4;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append(\'0\');\n                }\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, "Negative values should not be possible", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append(\'0\');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit number.</p>\n     */\n    private static class TwoDigitNumberField implements NumberRule {\n        private final int mField;\n\n        /**\n         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.\n         * \n         * @param field the field\n         */\n        TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit year.</p>\n     */\n    private static class TwoDigitYearField implements NumberRule {\n        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n\n        /**\n         * Constructs an instance of <code>TwoDigitYearField</code>.\n         */\n        TwoDigitYearField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + \'0\'));\n            buffer.append((char)(value % 10 + \'0\'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit month.</p>\n     */\n    private static class TwoDigitMonthField implements NumberRule {\n        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n\n        /**\n         * Constructs an instance of <code>TwoDigitMonthField</code>.\n         */\n        TwoDigitMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + \'0\'));\n            buffer.append((char)(value % 10 + \'0\'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twelve hour field.</p>\n     */\n    private static class TwelveHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of <code>TwelveHourField</code> with the specified\n         * <code>NumberRule</code>.\n         * \n         * @param rule the rule\n         */\n        TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twenty four hour field.</p>\n     */\n    private static class TwentyFourHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of <code>TwentyFourHourField</code> with the specified\n         * <code>NumberRule</code>.\n         * \n         * @param rule the rule\n         */\n        TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output a time zone name.</p>\n     */\n    private static class TimeZoneNameRule implements Rule {\n        private final TimeZone mTimeZone;\n        private final boolean mTimeZoneForced;\n        private final Locale mLocale;\n        private final int mStyle;\n        private final String mStandard;\n        private final String mDaylight;\n\n        /**\n         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n         * \n         * @param timeZone the time zone\n         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n         * @param locale the locale\n         * @param style the style\n         */\n        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n            mTimeZone = timeZone;\n            mTimeZoneForced = timeZoneForced;\n            mLocale = locale;\n            mStyle = style;\n\n            if (timeZoneForced) {\n                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n            } else {\n                mStandard = null;\n                mDaylight = null;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            if (mTimeZoneForced) {\n                return Math.max(mStandard.length(), mDaylight.length());\n            } else if (mStyle == TimeZone.SHORT) {\n                return 4;\n            } else {\n                return 40;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            if (mTimeZoneForced) {\n                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(mDaylight);\n                } else {\n                    buffer.append(mStandard);\n                }\n            } else {\n                TimeZone timeZone = calendar.getTimeZone();\n                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n                } else {\n                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>\n     * or <code>+/-HH:MM</code>.</p>\n     */\n    private static class TimeZoneNumberRule implements Rule {\n        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n        \n        final boolean mColon;\n        \n        /**\n         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.\n         * \n         * @param colon add colon between HH and MM in the output if <code>true</code>\n         */\n        TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 5;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n            \n            if (offset < 0) {\n                buffer.append(\'-\');\n                offset = -offset;\n            } else {\n                buffer.append(\'+\');\n            }\n            \n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + \'0\'));\n            buffer.append((char)(hours % 10 + \'0\'));\n            \n            if (mColon) {\n                buffer.append(\':\');\n            }\n            \n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + \'0\'));\n            buffer.append((char)(minutes % 10 + \'0\'));\n        }            \n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Inner class that acts as a compound key for time zone names.</p>\n     */\n    private static class TimeZoneDisplayKey {\n        private final TimeZone mTimeZone;\n        private final int mStyle;\n        private final Locale mLocale;\n\n        /**\n         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.\n         *  \n         * @param timeZone the time zone\n         * @param daylight adjust the style for daylight saving time if <code>true</code>\n         * @param style the timezone style\n         * @param locale the timezone locale\n         */\n        TimeZoneDisplayKey(TimeZone timeZone,\n                           boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int hashCode() {\n            return mStyle * 31 + mLocale.hashCode();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Helper class for creating compound objects.</p>\n     *\n     * <p>One use for this class is to create a hashtable key\n     * out of multiple objects.</p>\n     */\n    private static class Pair {\n        private final Object mObj1;\n        private final Object mObj2;\n\n        /**\n         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n         * @param obj1 one object in the pair\n         * @param obj2 second object in the pair\n         */\n        public Pair(Object obj1, Object obj2) {\n            mObj1 = obj1;\n            mObj2 = obj2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n\n            if (!(obj instanceof Pair)) {\n                return false;\n            }\n\n            Pair key = (Pair)obj;\n\n            return\n                (mObj1 == null ?\n                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n                (mObj2 == null ?\n                 key.mObj2 == null : mObj2.equals(key.mObj2));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int hashCode() {\n            return\n                (mObj1 == null ? 0 : mObj1.hashCode()) +\n                (mObj2 == null ? 0 : mObj2.hashCode());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String toString() {\n            return "[" + mObj1 + \':\' + mObj2 + \']\';\n        }\n    }\n\n}', 'tree': 'MethodDeclaration modifiers synchronized_ter ^ static_ter ^ public_ter ^ ^ return_type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ name meth0 ^ ^ parameters FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type ReferenceType name TimeZone_ter ^ ^ ^ ^ name par1 ^ ^ ^ FormalParameter type ReferenceType name Locale_ter ^ ^ ^ ^ name par2 ^ ^ ^ ^ body LocalVariableDeclaration type ReferenceType name Object_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer ClassCreator type ReferenceType name Integer_ter ^ ^ ^ ^ arguments MemberReference member par0 ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer Cast type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier cDateInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par2 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ TryStatement block LocalVariableDeclaration type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer Cast type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier DateFormat_ter ^ ^ arguments MemberReference member par0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name String_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation qualifier loc2 ^ ^ member toPattern_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par1 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier cDateInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ catches CatchClause parameter CatchClauseParameter types ClassCastException_ter ^ ^ name ex_ter ^ ^ ^ ^ block ThrowStatement expression ClassCreator type ReferenceType name IllegalArgumentException_ter ^ ^ ^ ^ arguments BinaryOperation operator +_ter ^ ^ operandl Literal value <string>_ter ^ ^ ^ ^ operandr MemberReference member par2 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ReturnStatement expression MemberReference member loc1 ^ ^ ^ ^ ^ ^ ^ ', 'prob': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 'mode': 0, 'line': 285, 'isa': False, 'fl_score': 1}, {'bugid': 'Lang-50', 'treeroot': <Searchnode.Node object at 0x7f6584e26d10>, 'troot': <Searchnode.Node object at 0x7f6584e26d10>, 'oldcode': '        if (locale != null) {', 'filepath': 'buggy/Lang-50/src/java/org/apache/commons/lang/time/FastDateFormat.java', 'subroot': <Searchnode.Node object at 0x7f6584e1c510>, 'vardic': {'getDateTimeInstance_ter': 'meth0', 'dateStyle_ter': 'par0', 'timeStyle_ter': 'par1', 'timeZone_ter': 'par2', 'locale_ter': 'par3', 'key_ter': 'loc0', 'format_ter': 'loc1', 'formatter_ter': 'loc2', 'pattern_ter': 'loc3'}, 'typedic': {'dateStyle_ter': 'int', 'timeStyle_ter': 'int', 'timeZone_ter': 'TimeZone', 'locale_ter': 'Locale', 'key_ter': 'Object', 'format_ter': 'FastDateFormat', 'formatter_ter': 'SimpleDateFormat', 'pattern_ter': 'String'}, 'idss': 'Lang-50', 'classname': 'org.apache.commons.lang.time.FastDateFormat', 'precode': '/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang.Validate;\n\n/**\n * <p>FastDateFormat is a fast and thread-safe version of\n * {@link java.text.SimpleDateFormat}.</p>\n * \n * <p>This class can be used as a direct replacement to\n * <code>SimpleDateFormat</code> in most formatting situations.\n * This class is especially useful in multi-threaded server environments.\n * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n * nor will it be as Sun have closed the bug/RFE.\n * </p>\n *\n * <p>Only formatting is supported, but all patterns are compatible with\n * SimpleDateFormat (except time zones - see below).</p>\n *\n * <p>Java 1.4 introduced a new pattern letter, <code>\'Z\'</code>, to represent\n * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n * This pattern letter can be used here (on all JDK versions).</p>\n *\n * <p>In addition, the pattern <code>\'ZZ\'</code> has been made to represent\n * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n * This introduces a minor incompatibility with Java 1.4, but at a gain of\n * useful functionality.</p>\n *\n * @author TeaTrove project\n * @author Brian S O\'Neill\n * @author Sean Schofield\n * @author Gary Gregory\n * @author Stephen Colebourne\n * @author Nikolay Metchev\n * @since 2.0\n * @version $Id$\n */\npublic class FastDateFormat extends Format {\n    // A lot of the speed in this class comes from caching, but some comes\n    // from the special int to StringBuffer conversion.\n    //\n    // The following produces a padded 2 digit number:\n    //   buffer.append((char)(value / 10 + \'0\'));\n    //   buffer.append((char)(value % 10 + \'0\'));\n    //\n    // Note that the fastest append to StringBuffer is a single char (used here).\n    // Note that Integer.toString() is not called, the conversion is simply\n    // taking the value and adding (mathematically) the ASCII value for \'0\'.\n    // So, don\'t change this code! It works and is very fast.\n    \n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * FULL locale dependent date or time style.\n     */\n    public static final int FULL = DateFormat.FULL;\n    /**\n     * LONG locale dependent date or time style.\n     */\n    public static final int LONG = DateFormat.LONG;\n    /**\n     * MEDIUM locale dependent date or time style.\n     */\n    public static final int MEDIUM = DateFormat.MEDIUM;\n    /**\n     * SHORT locale dependent date or time style.\n     */\n    public static final int SHORT = DateFormat.SHORT;\n    \n    private static String cDefaultPattern;\n\n    private static Map cInstanceCache = new HashMap(7);\n    private static Map cDateInstanceCache = new HashMap(7);\n    private static Map cTimeInstanceCache = new HashMap(7);\n    private static Map cDateTimeInstanceCache = new HashMap(7);\n    private static Map cTimeZoneDisplayCache = new HashMap(7);\n\n    /**\n     * The pattern.\n     */\n    private final String mPattern;\n    /**\n     * The time zone.\n     */\n    private final TimeZone mTimeZone;\n    /**\n     * Whether the time zone overrides any on Calendars.\n     */\n    private final boolean mTimeZoneForced;\n    /**\n     * The locale.\n     */\n    private final Locale mLocale;\n    /**\n     * Whether the locale overrides the default.\n     */\n    private final boolean mLocaleForced;\n    /**\n     * The parsed rules.\n     */\n    private transient Rule[] mRules;\n    /**\n     * The estimated maximum length.\n     */\n    private transient int mMaxLengthEstimate;\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a formatter instance using the default pattern in the\n     * default locale.</p>\n     * \n     * @return a date/time formatter\n     */\n    public static FastDateFormat getInstance() {\n        return getInstance(getDefaultPattern(), null, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern in the\n     * default locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern) {\n        return getInstance(pattern, null, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern and\n     * time zone.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n        return getInstance(pattern, timeZone, null);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern and\n     * locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param locale  optional locale, overrides system locale\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    public static FastDateFormat getInstance(String pattern, Locale locale) {\n        return getInstance(pattern, null, locale);\n    }\n\n    /**\n     * <p>Gets a formatter instance using the specified pattern, time zone\n     * and locale.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a pattern based date/time formatter\n     * @throws IllegalArgumentException if pattern is invalid\n     *  or <code>null</code>\n     */\n    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n        if (format == null) {\n            format = emptyFormat;\n            format.init();  // convert shell format into usable one\n            cInstanceCache.put(format, format);  // this is OK!\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a date formatter instance using the specified style in the\n     * default time zone and locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style) {\n        return getDateInstance(style, null, null);\n    }\n\n    /**\n     * <p>Gets a date formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style, Locale locale) {\n        return getDateInstance(style, null, locale);\n    }\n\n    /**\n     * <p>Gets a date formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n        return getDateInstance(style, timeZone, null);\n    }\n    /**\n     * <p>Gets a date formatter instance using the specified style, time\n     * zone and locale.</p>\n     * \n     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date formatter\n     * @throws IllegalArgumentException if the Locale has no date\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = new Integer(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n\n        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateInstanceCache.put(key, format);\n                \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a time formatter instance using the specified style in the\n     * default time zone and locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style) {\n        return getTimeInstance(style, null, null);\n    }\n\n    /**\n     * <p>Gets a time formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n        return getTimeInstance(style, null, locale);\n    }\n    \n    /**\n     * <p>Gets a time formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted time\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n        return getTimeInstance(style, timeZone, null);\n    }\n    \n    /**\n     * <p>Gets a time formatter instance using the specified style, time\n     * zone and locale.</p>\n     * \n     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted time\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard time formatter\n     * @throws IllegalArgumentException if the Locale has no time\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n        Object key = new Integer(style);\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cTimeInstanceCache.put(key, format);\n            \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets a date/time formatter instance using the specified style\n     * in the default time zone and locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style and\n     * locale in the default time zone.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle, Locale locale) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style and\n     * time zone in the default locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     * @since 2.1\n     */\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle, TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }    \n    /**\n     * <p>Gets a date/time formatter instance using the specified style,\n     * time zone and locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n            Locale locale) {\n\n        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }', 'aftercode': '            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                        locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateTimeInstanceCache.put(key, format);\n\n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException("No date time pattern for locale: " + locale);\n            }\n        }\n        return format;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the time zone display name, using a cache for performance.</p>\n     * \n     * @param tz  the zone to query\n     * @param daylight  true if daylight savings\n     * @param style  the style to use <code>TimeZone.LONG</code>\n     *  or <code>TimeZone.SHORT</code>\n     * @param locale  the locale to use\n     * @return the textual name of the time zone\n     */\n    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = (String) cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            // This is a very slow call, so cache the results.\n            value = tz.getDisplayName(daylight, style, locale);\n            cTimeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }\n\n    /**\n     * <p>Gets the default pattern.</p>\n     * \n     * @return the default pattern\n     */\n    private static synchronized String getDefaultPattern() {\n        if (cDefaultPattern == null) {\n            cDefaultPattern = new SimpleDateFormat().toPattern();\n        }\n        return cDefaultPattern;\n    }\n\n    // Constructor\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Constructs a new FastDateFormat.</p>\n     * \n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone  time zone to use, <code>null</code> means use\n     *  default for <code>Date</code> and value within for\n     *  <code>Calendar</code>\n     * @param locale  locale, <code>null</code> means use system\n     *  default\n     * @throws IllegalArgumentException if pattern is invalid or\n     *  <code>null</code>\n     */\n    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n        super();\n        if (pattern == null) {\n            throw new IllegalArgumentException("The pattern must not be null");\n        }\n        mPattern = pattern;\n        \n        mTimeZoneForced = (timeZone != null);\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        mTimeZone = timeZone;\n        \n        mLocaleForced = (locale != null);\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        mLocale = locale;\n    }\n\n    /**\n     * <p>Initializes the instance for first use.</p>\n     */\n    protected void init() {\n        List rulesList = parsePattern();\n        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }\n\n    // Parse the pattern\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     * \n     * @return a <code>List</code> of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List rules = new ArrayList();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case \'G\': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case \'y\': // year (number)\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case \'M\': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case \'d\': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case \'h\': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case \'H\': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case \'m\': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case \'s\': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case \'S\': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case \'E\': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case \'D\': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case \'F\': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case \'w\': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case \'W\': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case \'a\': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case \'k\': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case \'K\': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case \'z\': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case \'Z\': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case \'\\\'\': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException("Illegal pattern component: " + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n\n    /**\n     * <p>Performs the parsing of tokens.</p>\n     * \n     * @param pattern  the pattern\n     * @param indexRef  index references\n     * @return parsed token\n     */\n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuffer buf = new StringBuffer();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= \'A\' && c <= \'Z\' || c >= \'a\' && c <= \'z\') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append(\'\\\'\');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == \'\\\'\') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == \'\\\'\') {\n                        // \'\' is treated as escaped \'\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= \'A\' && c <= \'Z\' || c >= \'a\' && c <= \'z\')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    /**\n     * <p>Gets an appropriate rule for the padding required.</p>\n     * \n     * @param field  the field to get a rule for\n     * @param padding  the padding required\n     * @return a new rule with the correct padding\n     */\n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }\n\n    // Format methods\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Formats a <code>Date</code>, <code>Calendar</code> or\n     * <code>Long</code> (milliseconds) object.</p>\n     * \n     * @param obj  the object to format\n     * @param toAppendTo  the buffer to append to\n     * @param pos  the position - ignored\n     * @return the buffer passed in\n     */\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException("Unknown class: " +\n                (obj == null ? "<null>" : obj.getClass().getName()));\n        }\n    }\n\n    /**\n     * <p>Formats a millisecond <code>long</code> value.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @return the formatted string\n     * @since 2.1\n     */\n    public String format(long millis) {\n        return format(new Date(millis));\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object.</p>\n     * \n     * @param calendar  the calendar to format\n     * @return the formatted string\n     */\n    public String format(Calendar calendar) {\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n\n    /**\n     * <p>Formats a milliseond <code>long</code> value into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param millis  the millisecond value to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     * @since 2.1\n     */\n    public StringBuffer format(long millis, StringBuffer buf) {\n        return format(new Date(millis), buf);\n    }\n\n    /**\n     * <p>Formats a <code>Date</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param date  the date to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Date date, StringBuffer buf) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, buf);\n    }\n\n    /**\n     * <p>Formats a <code>Calendar</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n\n    /**\n     * <p>Performs the formatting by applying the rules to the\n     * specified calendar.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        Rule[] rules = mRules;\n        int len = mRules.length;\n        for (int i = 0; i < len; i++) {\n            rules[i].appendTo(buf, calendar);\n        }\n        return buf;\n    }\n\n    // Parsing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parsing is not supported.</p>\n     * \n     * @param source  the string to parse\n     * @param pos  the parsing position\n     * @return <code>null</code> as not supported\n     */\n    public Object parseObject(String source, ParsePosition pos) {\n        pos.setIndex(0);\n        pos.setErrorIndex(0);\n        return null;\n    }\n    \n    // Accessors\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the pattern used by this formatter.</p>\n     * \n     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n     */\n    public String getPattern() {\n        return mPattern;\n    }\n\n    /**\n     * <p>Gets the time zone used by this formatter.</p>\n     *\n     * <p>This zone is always used for <code>Date</code> formatting.\n     * If a <code>Calendar</code> is passed in to be formatted, the\n     * time zone on that may be used depending on\n     * {@link #getTimeZoneOverridesCalendar()}.</p>\n     * \n     * @return the time zone\n     */\n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }\n\n    /**\n     * <p>Returns <code>true</code> if the time zone of the\n     * calendar overrides the time zone of the formatter.</p>\n     * \n     * @return <code>true</code> if time zone of formatter\n     *  overridden for calendars\n     */\n    public boolean getTimeZoneOverridesCalendar() {\n        return mTimeZoneForced;\n    }\n\n    /**\n     * <p>Gets the locale used by this formatter.</p>\n     * \n     * @return the locale\n     */\n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    /**\n     * <p>Gets an estimate for the maximum string length that the\n     * formatter will produce.</p>\n     *\n     * <p>The actual formatted length will almost always be less than or\n     * equal to this amount.</p>\n     * \n     * @return the maximum formatted length\n     */\n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }\n\n    // Basics\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Compares two objects for equality.</p>\n     * \n     * @param obj  the object to compare to\n     * @return <code>true</code> if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDateFormat == false) {\n            return false;\n        }\n        FastDateFormat other = (FastDateFormat) obj;\n        if (\n            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n            (mTimeZoneForced == other.mTimeZoneForced) &&\n            (mLocaleForced == other.mLocaleForced)\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Returns a hashcode compatible with equals.</p>\n     * \n     * @return a hashcode compatible with equals\n     */\n    public int hashCode() {\n        int total = 0;\n        total += mPattern.hashCode();\n        total += mTimeZone.hashCode();\n        total += (mTimeZoneForced ? 1 : 0);\n        total += mLocale.hashCode();\n        total += (mLocaleForced ? 1 : 0);\n        return total;\n    }\n\n    /**\n     * <p>Gets a debugging string version of this formatter.</p>\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        return "FastDateFormat[" + mPattern + "]";\n    }\n\n    // Serializing\n    //-----------------------------------------------------------------------\n    /**\n     * Create the object after serialization. This implementation reinitializes the \n     * transient properties.\n     *\n     * @param in ObjectInputStream from which the object is being deserialized.\n     * @throws IOException if there is an IO issue.\n     * @throws ClassNotFoundException if a class cannot be found.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n    \n    // Rules\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Inner class defining a rule.</p>\n     */\n    private interface Rule {\n        /**\n         * Returns the estimated lentgh of the result.\n         * \n         * @return the estimated length\n         */\n        int estimateLength();\n        \n        /**\n         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n         * \n         * @param buffer the output buffer\n         * @param calendar calendar to be appended\n         */\n        void appendTo(StringBuffer buffer, Calendar calendar);\n    }\n\n    /**\n     * <p>Inner class defining a numeric rule.</p>\n     */\n    private interface NumberRule extends Rule {\n        /**\n         * Appends the specified value to the output buffer based on the rule implementation.\n         * \n         * @param buffer the output buffer\n         * @param value the value to be appended\n         */\n        void appendTo(StringBuffer buffer, int value);\n    }\n\n    /**\n     * <p>Inner class to output a constant single character.</p>\n     */\n    private static class CharacterLiteral implements Rule {\n        private final char mValue;\n\n        /**\n         * Constructs a new instance of <code>CharacterLiteral</code>\n         * to hold the specified value.\n         * \n         * @param value the character literal\n         */\n        CharacterLiteral(char value) {\n            mValue = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    /**\n     * <p>Inner class to output a constant string.</p>\n     */\n    private static class StringLiteral implements Rule {\n        private final String mValue;\n\n        /**\n         * Constructs a new instance of <code>StringLiteral</code>\n         * to hold the specified value.\n         * \n         * @param value the string literal\n         */\n        StringLiteral(String value) {\n            mValue = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mValue.length();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }\n    }\n\n    /**\n     * <p>Inner class to output one of a set of values.</p>\n     */\n    private static class TextField implements Rule {\n        private final int mField;\n        private final String[] mValues;\n\n        /**\n         * Constructs an instance of <code>TextField</code>\n         * with the specified field and values.\n         * \n         * @param field the field\n         * @param values the field values\n         */\n        TextField(int field, String[] values) {\n            mField = field;\n            mValues = values;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValues[calendar.get(mField)]);\n        }\n    }\n\n    /**\n     * <p>Inner class to output an unpadded number.</p>\n     */\n    private static class UnpaddedNumberField implements NumberRule {\n        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n        \n        private final int mField;\n\n        /**\n         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n         * \n         * @param field the field\n         */\n        UnpaddedNumberField(int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 4;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + \'0\'));\n            } else if (value < 100) {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output an unpadded month.</p>\n     */\n    private static class UnpaddedMonthField implements NumberRule {\n        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n\n        /**\n         * Constructs an instance of <code>UnpaddedMonthField</code>.\n         *\n         */\n        UnpaddedMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 10) {\n                buffer.append((char)(value + \'0\'));\n            } else {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a padded number.</p>\n     */\n    private static class PaddedNumberField implements NumberRule {\n        private final int mField;\n        private final int mSize;\n\n        /**\n         * Constructs an instance of <code>PaddedNumberField</code>.\n         * \n         * @param field the field\n         * @param size size of the output field\n         */\n        PaddedNumberField(int field, int size) {\n            if (size < 3) {\n                // Should use UnpaddedNumberField or TwoDigitNumberField.\n                throw new IllegalArgumentException();\n            }\n            mField = field;\n            mSize = size;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 4;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                for (int i = mSize; --i >= 2; ) {\n                    buffer.append(\'0\');\n                }\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                int digits;\n                if (value < 1000) {\n                    digits = 3;\n                } else {\n                    Validate.isTrue(value > -1, "Negative values should not be possible", value);\n                    digits = Integer.toString(value).length();\n                }\n                for (int i = mSize; --i >= digits; ) {\n                    buffer.append(\'0\');\n                }\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit number.</p>\n     */\n    private static class TwoDigitNumberField implements NumberRule {\n        private final int mField;\n\n        /**\n         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.\n         * \n         * @param field the field\n         */\n        TwoDigitNumberField(int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + \'0\'));\n                buffer.append((char)(value % 10 + \'0\'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit year.</p>\n     */\n    private static class TwoDigitYearField implements NumberRule {\n        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n\n        /**\n         * Constructs an instance of <code>TwoDigitYearField</code>.\n         */\n        TwoDigitYearField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + \'0\'));\n            buffer.append((char)(value % 10 + \'0\'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit month.</p>\n     */\n    private static class TwoDigitMonthField implements NumberRule {\n        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n\n        /**\n         * Constructs an instance of <code>TwoDigitMonthField</code>.\n         */\n        TwoDigitMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public final void appendTo(StringBuffer buffer, int value) {\n            buffer.append((char)(value / 10 + \'0\'));\n            buffer.append((char)(value % 10 + \'0\'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twelve hour field.</p>\n     */\n    private static class TwelveHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of <code>TwelveHourField</code> with the specified\n         * <code>NumberRule</code>.\n         * \n         * @param rule the rule\n         */\n        TwelveHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twenty four hour field.</p>\n     */\n    private static class TwentyFourHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of <code>TwentyFourHourField</code> with the specified\n         * <code>NumberRule</code>.\n         * \n         * @param rule the rule\n         */\n        TwentyFourHourField(NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output a time zone name.</p>\n     */\n    private static class TimeZoneNameRule implements Rule {\n        private final TimeZone mTimeZone;\n        private final boolean mTimeZoneForced;\n        private final Locale mLocale;\n        private final int mStyle;\n        private final String mStandard;\n        private final String mDaylight;\n\n        /**\n         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n         * \n         * @param timeZone the time zone\n         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n         * @param locale the locale\n         * @param style the style\n         */\n        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n            mTimeZone = timeZone;\n            mTimeZoneForced = timeZoneForced;\n            mLocale = locale;\n            mStyle = style;\n\n            if (timeZoneForced) {\n                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n            } else {\n                mStandard = null;\n                mDaylight = null;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            if (mTimeZoneForced) {\n                return Math.max(mStandard.length(), mDaylight.length());\n            } else if (mStyle == TimeZone.SHORT) {\n                return 4;\n            } else {\n                return 40;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            if (mTimeZoneForced) {\n                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(mDaylight);\n                } else {\n                    buffer.append(mStandard);\n                }\n            } else {\n                TimeZone timeZone = calendar.getTimeZone();\n                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n                } else {\n                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>\n     * or <code>+/-HH:MM</code>.</p>\n     */\n    private static class TimeZoneNumberRule implements Rule {\n        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n        \n        final boolean mColon;\n        \n        /**\n         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.\n         * \n         * @param colon add colon between HH and MM in the output if <code>true</code>\n         */\n        TimeZoneNumberRule(boolean colon) {\n            mColon = colon;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int estimateLength() {\n            return 5;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n            \n            if (offset < 0) {\n                buffer.append(\'-\');\n                offset = -offset;\n            } else {\n                buffer.append(\'+\');\n            }\n            \n            int hours = offset / (60 * 60 * 1000);\n            buffer.append((char)(hours / 10 + \'0\'));\n            buffer.append((char)(hours % 10 + \'0\'));\n            \n            if (mColon) {\n                buffer.append(\':\');\n            }\n            \n            int minutes = offset / (60 * 1000) - 60 * hours;\n            buffer.append((char)(minutes / 10 + \'0\'));\n            buffer.append((char)(minutes % 10 + \'0\'));\n        }            \n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Inner class that acts as a compound key for time zone names.</p>\n     */\n    private static class TimeZoneDisplayKey {\n        private final TimeZone mTimeZone;\n        private final int mStyle;\n        private final Locale mLocale;\n\n        /**\n         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.\n         *  \n         * @param timeZone the time zone\n         * @param daylight adjust the style for daylight saving time if <code>true</code>\n         * @param style the timezone style\n         * @param locale the timezone locale\n         */\n        TimeZoneDisplayKey(TimeZone timeZone,\n                           boolean daylight, int style, Locale locale) {\n            mTimeZone = timeZone;\n            if (daylight) {\n                style |= 0x80000000;\n            }\n            mStyle = style;\n            mLocale = locale;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int hashCode() {\n            return mStyle * 31 + mLocale.hashCode();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof TimeZoneDisplayKey) {\n                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                return\n                    mTimeZone.equals(other.mTimeZone) &&\n                    mStyle == other.mStyle &&\n                    mLocale.equals(other.mLocale);\n            }\n            return false;\n        }\n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Helper class for creating compound objects.</p>\n     *\n     * <p>One use for this class is to create a hashtable key\n     * out of multiple objects.</p>\n     */\n    private static class Pair {\n        private final Object mObj1;\n        private final Object mObj2;\n\n        /**\n         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n         * @param obj1 one object in the pair\n         * @param obj2 second object in the pair\n         */\n        public Pair(Object obj1, Object obj2) {\n            mObj1 = obj1;\n            mObj2 = obj2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n\n            if (!(obj instanceof Pair)) {\n                return false;\n            }\n\n            Pair key = (Pair)obj;\n\n            return\n                (mObj1 == null ?\n                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n                (mObj2 == null ?\n                 key.mObj2 == null : mObj2.equals(key.mObj2));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int hashCode() {\n            return\n                (mObj1 == null ? 0 : mObj1.hashCode()) +\n                (mObj2 == null ? 0 : mObj2.hashCode());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public String toString() {\n            return "[" + mObj1 + \':\' + mObj2 + \']\';\n        }\n    }\n\n}', 'tree': 'MethodDeclaration modifiers synchronized_ter ^ static_ter ^ public_ter ^ ^ return_type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ name meth0 ^ ^ parameters FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par1 ^ ^ ^ FormalParameter type ReferenceType name TimeZone_ter ^ ^ ^ ^ name par2 ^ ^ ^ FormalParameter type ReferenceType name Locale_ter ^ ^ ^ ^ name par3 ^ ^ ^ ^ body LocalVariableDeclaration type ReferenceType name Object_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments ClassCreator type ReferenceType name Integer_ter ^ ^ ^ ^ arguments MemberReference member par0 ^ ^ ^ ^ ^ ClassCreator type ReferenceType name Integer_ter ^ ^ ^ ^ arguments MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par3 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer Cast type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier cDateTimeInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par3 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par3 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ TryStatement block LocalVariableDeclaration type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer Cast type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier DateFormat_ter ^ ^ arguments MemberReference member par0 ^ ^ ^ MemberReference member par1 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name String_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation qualifier loc2 ^ ^ member toPattern_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par2 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier cDateTimeInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ catches CatchClause parameter CatchClauseParameter types ClassCastException_ter ^ ^ name ex_ter ^ ^ ^ ^ block ThrowStatement expression ClassCreator type ReferenceType name IllegalArgumentException_ter ^ ^ ^ ^ arguments BinaryOperation operator +_ter ^ ^ operandl Literal value <string>_ter ^ ^ ^ ^ operandr MemberReference member par3 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ReturnStatement expression MemberReference member loc1 ^ ^ ^ ^ ^ ^ ^ ', 'prob': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 'mode': 0, 'line': 465, 'isa': False, 'fl_score': 1}]
before@0 batch0 x: 0: root ^  ; []
after@0 batch0 x: 0: root ^  ; []
before@0 batch1 x: 0: root ^  ; []
after@0 batch1 x: 0: root ^  ; []
copynode 0:  root add ^ ^ ; ['root -> add']
copynode 0:  root modified ^ ^ ; ['root -> modified']
copynode 0:  root ReturnStatement ^ ^ ; ['root -> ReturnStatement']
copynode 0:  root ^ ; ['root -> End']
copynode 0:  root StatementExpression ^ ^ ; ['root -> StatementExpression']
copynode 0:  root IfStatement ^ ^ ; ['root -> IfStatement']
copynode 0:  root return_type ^ ^ ; ['root -> return_type']
copynode 0:  root parameters ^ ^ ; ['root -> parameters']
copynode 0:  root operator-operator !=_ter ^ ^  ^ ^ ; ['copy-operator']
copynode 0:  root MemberReference-MemberReference member par2 ^ ^ ^  ^ ^ ; ['copy-MemberReference']
copynode 0:  root add ^ ^ ; ['root -> add']
copynode 0:  root modified ^ ^ ; ['root -> modified']
copynode 0:  root ReturnStatement ^ ^ ; ['root -> ReturnStatement']
copynode 0:  root ^ ; ['root -> End']
copynode 0:  root StatementExpression ^ ^ ; ['root -> StatementExpression']
copynode 0:  root parameters ^ ^ ; ['root -> parameters']
copynode 0:  root IfStatement ^ ^ ; ['root -> IfStatement']
copynode 0:  root return_type ^ ^ ; ['root -> return_type']
copynode 0:  root operator-operator !=_ter ^ ^  ^ ^ ; ['copy-operator']
copynode 0:  root MemberReference-MemberReference member par3 ^ ^ ^  ^ ^ ; ['copy-MemberReference']
before@1 batch0 x: -11.822497367858887: root MemberReference-MemberReference member par2 ^ ^ ^  ^ ^  ; ['copy-MemberReference']
after@1 batch0 x: -11.822497367858887: root MemberReference-MemberReference member par2 ^ ^ ^  ^ ^  ; ['copy-MemberReference']
before@1 batch1 x: -11.846067428588867: root MemberReference-MemberReference member par3 ^ ^ ^  ^ ^  ; ['copy-MemberReference']
after@1 batch1 x: -11.846067428588867: root MemberReference-MemberReference member par3 ^ ^ ^  ^ ^  ; ['copy-MemberReference']
copynode -0.5238121747970581:  root add ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression']
copynode -0.901091456413269:  root modified ^ IfStatement ^ ^ ; ['root -> modified', 'root -> IfStatement']
copynode -0.5238121747970581:  root add ^ IfStatement ^ ^ ; ['root -> add', 'root -> IfStatement']
copynode -0.901091456413269:  root modified ^ operator-operator !=_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.5238121747970581:  root add ^ ReturnStatement ^ ^ ; ['root -> add', 'root -> ReturnStatement']
copynode -0.901091456413269:  root modified ^ MemberReference-MemberReference member par2 ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.5238121747970581:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter']
copynode -0.5238121747970581:  root add ^ BreakStatement_ter ^ ^ ; ['root -> add', 'root -> BreakStatement_ter']
copynode -0.901091456413269:  root modified ^ StatementExpression ^ ^ ; ['root -> modified', 'root -> StatementExpression']
copynode -0.901091456413269:  root modified ^ ^ ; ['root -> modified', 'root -> End']
copynode -0.5238121747970581:  root add ^ LocalVariableDeclaration ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration']
copynode -0.5238121747970581:  root add ^ control ^ ^ ; ['root -> add', 'root -> control']
copynode -0.901091456413269:  root modified ^ Literal-Literal value null_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-Literal']
copynode -0.5238121747970581:  root add ^ ContinueStatement_ter ^ ^ ; ['root -> add', 'root -> ContinueStatement_ter']
copynode -0.5238121747970581:  root add ^ ^ ; ['root -> add', 'root -> End']
copynode -7.249081611633301:  root ReturnStatement expression ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -0.5238121747970581:  root add ^ WhileStatement ^ ^ ; ['root -> add', 'root -> WhileStatement']
copynode -7.249081611633301:  root ReturnStatement expression MemberReference member loc1 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -0.901091456413269:  root modified ^ BreakStatement_ter ^ ^ ; ['root -> modified', 'root -> BreakStatement_ter']
copynode -9.035407066345215:  root StatementExpression expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression']
copynode -9.570281028747559:  root IfStatement condition ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition']
copynode -0.901091456413269:  root modified ^ ReturnStatement_ter ^ ^ ; ['root -> modified', 'root -> ReturnStatement_ter']
copynode -9.79018497467041:  root parameters FormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> FormalParameter']
copynode -9.63794994354248:  root return_type ReferenceType ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType']
copynode -0.901091456413269:  root modified ^ WhileStatement ^ ^ ; ['root -> modified', 'root -> WhileStatement']
copynode -0.901091456413269:  root modified ^ par0 ^ ^ ; ['root -> modified', 'copy-FormalParameter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> member']
copynode -9.63794994354248:  root return_type BasicType ^ ^ ^ ; ['root -> return_type', 'return_type -> BasicType']
copynode -9.035407066345215:  root StatementExpression expression Assignment expressionl MemberReference member par2 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.035407066345215:  root StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.035407066345215:  root StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.035407066345215:  root StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par1 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.035407066345215:  root StatementExpression expression MethodInvocation qualifier cDateInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.79018497467041:  root parameters ^ ^ ; ['root -> parameters', 'parameters -> End']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  >_ter ^ ^ ^ ; ['copy-operator', 'operator -> >_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  &&_ter ^ ^ ^ ; ['copy-operator', 'operator -> &&_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  >=_ter ^ ^ ^ ; ['copy-operator', 'operator -> >=_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  +_ter ^ ^ ^ ; ['copy-operator', 'operator -> +_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  <_ter ^ ^ ^ ; ['copy-operator', 'operator -> <_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  -_ter ^ ^ ^ ; ['copy-operator', 'operator -> -_ter']
copynode -10.363048553466797:  root operator-operator !=_ter ^ ^  ||_ter ^ ^ ^ ; ['copy-operator', 'operator -> ||_ter']
copynode -9.79018497467041:  root parameters FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type ReferenceType name TimeZone_ter ^ ^ ^ ^ name par1 ^ ^ ^ FormalParameter type ReferenceType name Locale_ter ^ ^ ^ ^ name par2 ^ ^ ^ ^ ^ ; ['root -> parameters', 'copy-parameters']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier member']
copynode -9.79018497467041:  root parameters MemberReference ^ ^ ^ ; ['root -> parameters', 'parameters -> MemberReference']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -9.79018497467041:  root parameters InferredFormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> InferredFormalParameter']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -9.63794994354248:  root return_type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ ^ ; ['root -> return_type', 'copy-return_type']
copynode -7.249081611633301:  root ReturnStatement par1 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -7.249081611633301:  root ReturnStatement par0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -7.249081611633301:  root ReturnStatement par2 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> selectors member']
copynode -9.63794994354248:  root return_type par0 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.570281028747559:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par2 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.79018497467041:  root parameters Cast ^ ^ ^ ; ['root -> parameters', 'parameters -> Cast']
copynode -9.63794994354248:  root return_type par2 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.63794994354248:  root return_type par1 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.79018497467041:  root parameters loc0 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.79018497467041:  root parameters loc1 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.79018497467041:  root parameters loc3 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -7.249081611633301:  root ReturnStatement unknown ^ ^ ^ ; ['root -> ReturnStatement', 'start -> unknown']
copynode -9.79018497467041:  root parameters loc2 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -9.570281028747559:  root IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.570281028747559:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par2 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ TryStatement block LocalVariableDeclaration type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer Cast type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier DateFormat_ter ^ ^ arguments MemberReference member par0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name String_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation qualifier loc2 ^ ^ member toPattern_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par1 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier cDateInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ catches CatchClause parameter CatchClauseParameter types ClassCastException_ter ^ ^ name ex_ter ^ ^ ^ ^ block ThrowStatement expression ClassCreator type ReferenceType name IllegalArgumentException_ter ^ ^ ^ ^ arguments BinaryOperation operator +_ter ^ ^ operandl Literal value <string>_ter ^ ^ ^ ^ operandr MemberReference member par2 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.570281028747559:  root IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.035407066345215:  root StatementExpression unknown ^ ^ ^ ; ['root -> StatementExpression', 'start -> unknown']
copynode -9.035407066345215:  root StatementExpression par0 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -9.570281028747559:  root IfStatement unknown ^ ^ ^ ; ['root -> IfStatement', 'start -> unknown']
copynode -9.570281028747559:  root IfStatement par1 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -9.035407066345215:  root StatementExpression par1 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -9.570281028747559:  root IfStatement condition ^ then_statement ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition then_statement']
copynode -9.570281028747559:  root IfStatement par2 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -9.570281028747559:  root IfStatement par0 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -9.035407066345215:  root StatementExpression par2 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  postfix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators selectors member']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -9.63794994354248:  root return_type unknown ^ ^ ^ ; ['root -> return_type', 'start -> unknown']
copynode -11.822497367858887:  root MemberReference-MemberReference member par2 ^ ^ ^  prefix_operators ^ postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators postfix_operators member']
copynode -9.63794994354248:  root return_type loc3 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -9.63794994354248:  root return_type loc0 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -9.63794994354248:  root return_type loc2 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -7.249081611633301:  root ReturnStatement loc2 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -7.249081611633301:  root ReturnStatement loc0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -7.249081611633301:  root ReturnStatement loc3 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -7.249081611633301:  root ReturnStatement loc1 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -0.532996654510498:  root add ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression']
copynode -0.8887152671813965:  root modified ^ IfStatement ^ ^ ; ['root -> modified', 'root -> IfStatement']
copynode -0.532996654510498:  root add ^ IfStatement ^ ^ ; ['root -> add', 'root -> IfStatement']
copynode -0.8887152671813965:  root modified ^ operator-operator !=_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.532996654510498:  root add ^ ReturnStatement ^ ^ ; ['root -> add', 'root -> ReturnStatement']
copynode -0.8887152671813965:  root modified ^ MemberReference-MemberReference member par3 ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.532996654510498:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter']
copynode -0.532996654510498:  root add ^ BreakStatement_ter ^ ^ ; ['root -> add', 'root -> BreakStatement_ter']
copynode -0.8887152671813965:  root modified ^ StatementExpression ^ ^ ; ['root -> modified', 'root -> StatementExpression']
copynode -0.532996654510498:  root add ^ LocalVariableDeclaration ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration']
copynode -0.532996654510498:  root add ^ control ^ ^ ; ['root -> add', 'root -> control']
copynode -0.8887152671813965:  root modified ^ Literal-Literal value null_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-Literal']
copynode -0.532996654510498:  root add ^ ContinueStatement_ter ^ ^ ; ['root -> add', 'root -> ContinueStatement_ter']
copynode -0.8887152671813965:  root modified ^ ^ ; ['root -> modified', 'root -> End']
copynode -0.532996654510498:  root add ^ ^ ; ['root -> add', 'root -> End']
copynode -7.013547420501709:  root ReturnStatement expression ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -0.532996654510498:  root add ^ WhileStatement ^ ^ ; ['root -> add', 'root -> WhileStatement']
copynode -7.013547420501709:  root ReturnStatement expression MemberReference member loc1 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -8.884495735168457:  root StatementExpression expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression']
copynode -9.259573936462402:  root parameters FormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> FormalParameter']
copynode -9.308629035949707:  root IfStatement condition ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition']
copynode -0.8887152671813965:  root modified ^ BreakStatement_ter ^ ^ ; ['root -> modified', 'root -> BreakStatement_ter']
copynode -9.362754821777344:  root return_type ReferenceType ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType']
copynode -0.8887152671813965:  root modified ^ ReturnStatement_ter ^ ^ ; ['root -> modified', 'root -> ReturnStatement_ter']
copynode -0.8887152671813965:  root modified ^ par1 ^ ^ ; ['root -> modified', 'copy-FormalParameter']
copynode -0.8887152671813965:  root modified ^ par0 ^ ^ ; ['root -> modified', 'copy-FormalParameter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -9.362754821777344:  root return_type BasicType ^ ^ ^ ; ['root -> return_type', 'return_type -> BasicType']
copynode -8.884495735168457:  root StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> member']
copynode -8.884495735168457:  root StatementExpression expression Assignment expressionl MemberReference member par3 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -8.884495735168457:  root StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -8.884495735168457:  root StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par2 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -8.884495735168457:  root StatementExpression expression MethodInvocation qualifier cDateTimeInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.259573936462402:  root parameters ^ ^ ; ['root -> parameters', 'parameters -> End']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  >_ter ^ ^ ^ ; ['copy-operator', 'operator -> >_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  &&_ter ^ ^ ^ ; ['copy-operator', 'operator -> &&_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  >=_ter ^ ^ ^ ; ['copy-operator', 'operator -> >=_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  <_ter ^ ^ ^ ; ['copy-operator', 'operator -> <_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  +_ter ^ ^ ^ ; ['copy-operator', 'operator -> +_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  -_ter ^ ^ ^ ; ['copy-operator', 'operator -> -_ter']
copynode -10.542786598205566:  root operator-operator !=_ter ^ ^  ||_ter ^ ^ ^ ; ['copy-operator', 'operator -> ||_ter']
copynode -9.259573936462402:  root parameters MemberReference ^ ^ ^ ; ['root -> parameters', 'parameters -> MemberReference']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier member']
copynode -9.259573936462402:  root parameters FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par1 ^ ^ ^ FormalParameter type ReferenceType name TimeZone_ter ^ ^ ^ ^ name par2 ^ ^ ^ FormalParameter type ReferenceType name Locale_ter ^ ^ ^ ^ name par3 ^ ^ ^ ^ ^ ; ['root -> parameters', 'copy-parameters']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -9.259573936462402:  root parameters InferredFormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> InferredFormalParameter']
copynode -9.362754821777344:  root return_type ReferenceType name FastDateFormat_ter ^ ^ ^ ^ ^ ; ['root -> return_type', 'copy-return_type']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -7.013547420501709:  root ReturnStatement par1 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -7.013547420501709:  root ReturnStatement par3 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -7.013547420501709:  root ReturnStatement par0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -7.013547420501709:  root ReturnStatement par2 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> selectors member']
copynode -9.362754821777344:  root return_type par0 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.362754821777344:  root return_type par2 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.362754821777344:  root return_type par3 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.362754821777344:  root return_type par1 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -9.259573936462402:  root parameters Cast ^ ^ ^ ; ['root -> parameters', 'parameters -> Cast']
copynode -9.308629035949707:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par3 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par3 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.259573936462402:  root parameters loc2 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.259573936462402:  root parameters loc0 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.308629035949707:  root IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par2 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par2 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.259573936462402:  root parameters loc3 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.259573936462402:  root parameters loc1 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -9.308629035949707:  root IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par3 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Pair_ter ^ ^ ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -7.013547420501709:  root ReturnStatement unknown ^ ^ ^ ; ['root -> ReturnStatement', 'start -> unknown']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -9.308629035949707:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par3 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member par3 ^ ^ ^ ^ value MethodInvocation qualifier Locale_ter ^ ^ member getDefault_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ TryStatement block LocalVariableDeclaration type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer Cast type ReferenceType name SimpleDateFormat_ter ^ ^ ^ ^ expression MethodInvocation qualifier DateFormat_ter ^ ^ arguments MemberReference member par0 ^ ^ ^ MemberReference member par1 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name String_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation qualifier loc2 ^ ^ member toPattern_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par2 ^ ^ ^ MemberReference member par3 ^ ^ ^ ^ member getInstance_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier cDateTimeInstanceCache_ter ^ ^ arguments MemberReference member loc0 ^ ^ ^ MemberReference member loc1 ^ ^ ^ ^ member put_ter ^ ^ ^ ^ ^ ^ catches CatchClause parameter CatchClauseParameter types ClassCastException_ter ^ ^ name ex_ter ^ ^ ^ ^ block ThrowStatement expression ClassCreator type ReferenceType name IllegalArgumentException_ter ^ ^ ^ ^ arguments BinaryOperation operator +_ter ^ ^ operandl Literal value <string>_ter ^ ^ ^ ^ operandr MemberReference member par3 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -8.884495735168457:  root StatementExpression unknown ^ ^ ^ ; ['root -> StatementExpression', 'start -> unknown']
copynode -9.308629035949707:  root IfStatement unknown ^ ^ ^ ; ['root -> IfStatement', 'start -> unknown']
copynode -9.308629035949707:  root IfStatement par1 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -8.884495735168457:  root StatementExpression par0 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -9.308629035949707:  root IfStatement condition ^ then_statement ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition then_statement']
copynode -9.308629035949707:  root IfStatement par3 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -9.308629035949707:  root IfStatement par2 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -8.884495735168457:  root StatementExpression par1 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -9.362754821777344:  root return_type unknown ^ ^ ^ ; ['root -> return_type', 'start -> unknown']
copynode -9.362754821777344:  root return_type loc2 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -8.884495735168457:  root StatementExpression par2 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  postfix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators selectors member']
copynode -9.362754821777344:  root return_type loc1 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.846067428588867:  root MemberReference-MemberReference member par3 ^ ^ ^  prefix_operators ^ postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators postfix_operators member']
copynode -7.013547420501709:  root ReturnStatement loc2 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -7.013547420501709:  root ReturnStatement loc1 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -7.013547420501709:  root ReturnStatement loc0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
before@2 batch0 x: -27.517069816589355: root ReturnStatement loc1 ^ ^ ^  ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
after@2 batch0 x: -27.517069816589355: root ReturnStatement loc1 ^ ^ ^  ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
before@2 batch1 x: -27.037597179412842: root ReturnStatement loc0 ^ ^ ^  ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
stderr: Check out program version: Lang-50b........................................ OK
OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0
Running ant (export.dir.src.classes)....................................... OK

  0%|          | 0/1 [00:00<?, ?it/s]/root/projects/Recoder-bwk/run.py:527: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  tmpdepth = np.array(tmpdepth)
/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py:1340: UserWarning: nn.functional.tanh is deprecated. Use torch.tanh instead.
  warnings.warn("nn.functional.tanh is deprecated. Use torch.tanh instead.")
  0%|          | 0/1 [00:04<?, ?it/s]
Traceback (most recent call last):
  File "testDefect4j.py", line 638, in <module>
    ans = solveone(data, model)
  File "/root/projects/Recoder-bwk/run.py", line 1100, in solveone
    ans = BeamSearch((x[0], x[1], None, None, None, None, None, None, x[2], x[3]), dev_set, model, 100, args.batch_size, indexs)
  File "/root/projects/Recoder-bwk/run.py", line 541, in BeamSearch
    result = model(gVar(tmpnl), gVar(tmpnlad), gVar(tmprule), gVar(tmpruleparent), gVar(tmprulechild), gVar(tmpAd), gVar(tmptreepath), gVar(tmpnl8), gVar(tmpnl9), tmpf, tmpc, tmpindex, tmpchar, tmpindex2, rulead, antimasks, None, "test")
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 172, in forward
    genP1, _ = self.copy2(rulenoter.unsqueeze(0), decode)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 79, in forward
    genP = self.LinearRes(F.tanh(sourceLinear.unsqueeze(1) + targetLinear.unsqueeze(2))).squeeze(-1)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py", line 1341, in tanh
    return input.tanh()
RuntimeError: CUDA out of memory. Tried to allocate 1.88 GiB (GPU 0; 23.65 GiB total capacity; 2.74 GiB already allocated; 1.05 GiB free; 3.43 GiB cached)
