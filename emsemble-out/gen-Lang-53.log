stdout: else_statement -> BlockStatement
using GPU
p
path org.apache.commons.lang.time.DateUtils
modify
Position(line=620, column=20)
FOUND IT!
path org.apache.commons.lang.time.DateUtils
modify
Position(line=620, column=20)
FOUND IT!
[{'bugid': 'Lang-53', 'treeroot': <Searchnode.Node object at 0x7f6417755110>, 'troot': <Searchnode.Node object at 0x7f6420ab96d0>, 'oldcode': '        if (!round || millisecs < 500) {', 'filepath': 'buggy/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java', 'subroot': <Searchnode.Node object at 0x7f64177636d0>, 'vardic': {'modify_ter': 'meth0', 'seconds_ter': 'loc0', 'millisecs_ter': 'loc4'}, 'typedic': {'seconds_ter': 'int', 'millisecs_ter': 'int'}, 'idss': 'Lang-53', 'classname': 'org.apache.commons.lang.time.DateUtils', 'precode': '/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n/**\n * <p>A suite of utilities surrounding the use of the\n * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n *\n * @author <a href="mailto:sergek@lokitech.com">Serge Knystautas</a>\n * @author Stephen Colebourne\n * @author Janek Bogucki\n * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>\n * @author Phil Steitz\n * @since 2.0\n * @version $Id$\n */\npublic class DateUtils {\n    \n    /**\n     * The UTC time zone  (often referred to as GMT).\n     */\n    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("GMT");\n    /**\n     * Number of milliseconds in a standard second.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    /**\n     * Number of milliseconds in a standard hour.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n    /**\n     * Number of milliseconds in a standard day.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n    /**\n     * This is half a month, so this represents whether a date is in the top\n     * or bottom half of the month.\n     */\n    public final static int SEMI_MONTH = 1001;\n\n    private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    /**\n     * A week range, starting on Sunday.\n     */\n    public final static int RANGE_WEEK_SUNDAY = 1;\n\n    /**\n     * A week range, starting on Monday.\n     */\n    public final static int RANGE_WEEK_MONDAY = 2;\n\n    /**\n     * A week range, starting on the day focused.\n     */\n    public final static int RANGE_WEEK_RELATIVE = 3;\n\n    /**\n     * A week range, centered around the day focused.\n     */\n    public final static int RANGE_WEEK_CENTER = 4;\n\n    /**\n     * A month range, the week starting on Sunday.\n     */\n    public final static int RANGE_MONTH_SUNDAY = 5;\n\n    /**\n     * A month range, the week starting on Monday.\n     */\n    public final static int RANGE_MONTH_MONDAY = 6;\n\n    /**\n     * <p><code>DateUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>DateUtils.parse(str);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public DateUtils() {\n        super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    /**\n     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either calendar is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    /**\n     * <p>Checks if two calendar objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed sucessful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * \n     * @param str  the date to parse, not null\n     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n     * @return the parsed date\n     * @throws IllegalArgumentException if the date string or pattern array is null\n     * @throws ParseException if none of the date patterns were suitable\n     */\n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException("Date and Patterns must not be null");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException("Unable to parse the date: " + str, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of years to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of months to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of weeks to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of days to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of hours to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of minutes to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of seconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of milliseconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param calendarField  the calendar field to add to\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with, either Date or Calendar\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ClassCastException if the object type is not a <code>Date</code>\n     *  or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException("Could not round " + date);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with, either <code>Date</code>\n     *  or <code>Calendar</code>\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is not a\n     *  <code>Date</code> or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException("Could not truncate " + date);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException("Calendar value too large for accurate calculations");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);', 'aftercode': '            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that\'s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we\'re going to drop the DATE field\'s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we\'re above 15 days adjustment, that means we\'re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we\'re in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we\'re going to drop the HOUR field\'s value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException("The field " + field + " is not supported");\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with, not null\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator, which always returns Calendar instances\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                //Set start to the first of the month\n                start = truncate(focus, Calendar.MONTH);\n                //Set end to the last of the month\n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                //Loop start back to the previous sunday or monday\n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                //Set start and end to the current date\n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        //already set by default\n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid.");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * @param focus  the date to work with, either\n     *  <code>Date</code> or <code>Calendar</code>\n     * @param rangeStyle  the style constant to use. Must be one of the range\n     * styles listed for the {@link #iterator(Calendar, int)} method.\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is\n     *  not a <code>Date</code> or <code>Calendar</code>\n     */\n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException("Could not iterate based on " + focus);\n        }\n    }\n\n    /**\n     * <p>Date iterator.</p>\n     */\n    static class DateIterator implements Iterator {\n        private final Calendar endFinal;\n        private final Calendar spot;\n        \n        /**\n         * Constructs a DateIterator that ranges from one date to another. \n         *\n         * @param startFinal start date (inclusive)\n         * @param endFinal end date (not inclusive)\n         */\n        DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        /**\n         * Has the iterator not reached the end date yet?\n         *\n         * @return <code>true</code> if the iterator has yet to reach the end date\n         */\n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        /**\n         * Return the next calendar in the iteration\n         *\n         * @return Object calendar for the next date\n         */\n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        /**\n         * Always throws UnsupportedOperationException.\n         * \n         * @throws UnsupportedOperationException\n         * @see java.util.Iterator#remove()\n         */\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    //------------------------------------------------------------------------- \n    // Deprecated int constants\n    // TODO: Remove in 3.0\n    \n    /**\n     * Number of milliseconds in a standard second.\n     * \n     * @deprecated Use MILLIS_PER_SECOND. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     * \n     * @deprecated Use MILLIS_PER_MINUTE. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    /**\n     * Number of milliseconds in a standard hour.\n     * \n     * @deprecated Use MILLIS_PER_HOUR. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    /**\n     * Number of milliseconds in a standard day.\n     * \n     * @deprecated Use MILLIS_PER_DAY. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}', 'tree': 'body IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member MILLISECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member MILLISECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member MILLISECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member MILLISECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ', 'prob': [0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 'mode': 0, 'line': 641, 'isa': False, 'fl_score': 1}, {'bugid': 'Lang-53', 'treeroot': <Searchnode.Node object at 0x7f6414ebf050>, 'troot': <Searchnode.Node object at 0x7f642060acd0>, 'oldcode': '        if (!done && (!round || seconds < 30)) {', 'filepath': 'buggy/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java', 'subroot': <Searchnode.Node object at 0x7f6414ec6d10>, 'vardic': {'modify_ter': 'meth0', 'minutes_ter': 'loc0', 'seconds_ter': 'loc4'}, 'typedic': {'minutes_ter': 'int', 'seconds_ter': 'int'}, 'idss': 'Lang-53', 'classname': 'org.apache.commons.lang.time.DateUtils', 'precode': '/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n/**\n * <p>A suite of utilities surrounding the use of the\n * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n *\n * @author <a href="mailto:sergek@lokitech.com">Serge Knystautas</a>\n * @author Stephen Colebourne\n * @author Janek Bogucki\n * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>\n * @author Phil Steitz\n * @since 2.0\n * @version $Id$\n */\npublic class DateUtils {\n    \n    /**\n     * The UTC time zone  (often referred to as GMT).\n     */\n    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("GMT");\n    /**\n     * Number of milliseconds in a standard second.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    /**\n     * Number of milliseconds in a standard hour.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n    /**\n     * Number of milliseconds in a standard day.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n    /**\n     * This is half a month, so this represents whether a date is in the top\n     * or bottom half of the month.\n     */\n    public final static int SEMI_MONTH = 1001;\n\n    private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    /**\n     * A week range, starting on Sunday.\n     */\n    public final static int RANGE_WEEK_SUNDAY = 1;\n\n    /**\n     * A week range, starting on Monday.\n     */\n    public final static int RANGE_WEEK_MONDAY = 2;\n\n    /**\n     * A week range, starting on the day focused.\n     */\n    public final static int RANGE_WEEK_RELATIVE = 3;\n\n    /**\n     * A week range, centered around the day focused.\n     */\n    public final static int RANGE_WEEK_CENTER = 4;\n\n    /**\n     * A month range, the week starting on Sunday.\n     */\n    public final static int RANGE_MONTH_SUNDAY = 5;\n\n    /**\n     * A month range, the week starting on Monday.\n     */\n    public final static int RANGE_MONTH_MONDAY = 6;\n\n    /**\n     * <p><code>DateUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>DateUtils.parse(str);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public DateUtils() {\n        super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    /**\n     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either calendar is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    /**\n     * <p>Checks if two calendar objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed sucessful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * \n     * @param str  the date to parse, not null\n     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n     * @return the parsed date\n     * @throws IllegalArgumentException if the date string or pattern array is null\n     * @throws ParseException if none of the date patterns were suitable\n     */\n    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException("Date and Patterns must not be null");\n        }\n        \n        SimpleDateFormat parser = null;\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n            if (i == 0) {\n                parser = new SimpleDateFormat(parsePatterns[0]);\n            } else {\n                parser.applyPattern(parsePatterns[i]);\n            }\n            pos.setIndex(0);\n            Date date = parser.parse(str, pos);\n            if (date != null && pos.getIndex() == str.length()) {\n                return date;\n            }\n        }\n        throw new ParseException("Unable to parse the date: " + str, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of years to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of months to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of weeks to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of days to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of hours to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of minutes to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of seconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of milliseconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param calendarField  the calendar field to add to\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, true);\n        return rounded;\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with, either Date or Calendar\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ClassCastException if the object type is not a <code>Date</code>\n     *  or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException("Could not round " + date);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, false);\n        return truncated;\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with, either <code>Date</code>\n     *  or <code>Calendar</code>\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is not a\n     *  <code>Date</code> or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException("Could not truncate " + date);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException("Calendar value too large for accurate calculations");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);', 'aftercode': '            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that\'s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we\'re going to drop the DATE field\'s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we\'re above 15 days adjustment, that means we\'re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we\'re in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we\'re going to drop the HOUR field\'s value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException("The field " + field + " is not supported");\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with, not null\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator, which always returns Calendar instances\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                //Set start to the first of the month\n                start = truncate(focus, Calendar.MONTH);\n                //Set end to the last of the month\n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                //Loop start back to the previous sunday or monday\n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                //Set start and end to the current date\n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        //already set by default\n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid.");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * @param focus  the date to work with, either\n     *  <code>Date</code> or <code>Calendar</code>\n     * @param rangeStyle  the style constant to use. Must be one of the range\n     * styles listed for the {@link #iterator(Calendar, int)} method.\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is\n     *  not a <code>Date</code> or <code>Calendar</code>\n     */\n    public static Iterator iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException("The date must not be null");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException("Could not iterate based on " + focus);\n        }\n    }\n\n    /**\n     * <p>Date iterator.</p>\n     */\n    static class DateIterator implements Iterator {\n        private final Calendar endFinal;\n        private final Calendar spot;\n        \n        /**\n         * Constructs a DateIterator that ranges from one date to another. \n         *\n         * @param startFinal start date (inclusive)\n         * @param endFinal end date (not inclusive)\n         */\n        DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        /**\n         * Has the iterator not reached the end date yet?\n         *\n         * @return <code>true</code> if the iterator has yet to reach the end date\n         */\n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        /**\n         * Return the next calendar in the iteration\n         *\n         * @return Object calendar for the next date\n         */\n        public Object next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return spot.clone();\n        }\n\n        /**\n         * Always throws UnsupportedOperationException.\n         * \n         * @throws UnsupportedOperationException\n         * @see java.util.Iterator#remove()\n         */\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n    //------------------------------------------------------------------------- \n    // Deprecated int constants\n    // TODO: Remove in 3.0\n    \n    /**\n     * Number of milliseconds in a standard second.\n     * \n     * @deprecated Use MILLIS_PER_SECOND. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     * \n     * @deprecated Use MILLIS_PER_MINUTE. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n    /**\n     * Number of milliseconds in a standard hour.\n     * \n     * @deprecated Use MILLIS_PER_HOUR. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n    /**\n     * Number of milliseconds in a standard day.\n     * \n     * @deprecated Use MILLIS_PER_DAY. This will be removed in Commons Lang 3.0.\n     */\n    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n    \n}', 'tree': 'body IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation qualifier val_ter ^ ^ arguments MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ member get_ter ^ ^ ^ ^ ^ ^ ^ ^ ', 'prob': [0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], 'mode': 0, 'line': 650, 'isa': False, 'fl_score': 1}]
before@0 batch0 x: 0: root ^  ; []
after@0 batch0 x: 0: root ^  ; []
before@0 batch1 x: 0: root ^  ; []
after@0 batch1 x: 0: root ^  ; []
copynode 0:  root modified ^ ^ ; ['root -> modified']
copynode 0:  root add ^ ^ ; ['root -> add']
copynode 0:  root ^ ; ['root -> End']
copynode 0:  root operator-operator <_ter ^ ^  ^ ^ ; ['copy-operator']
copynode 0:  root Literal-Literal value 500_ter ^ ^ ^  ^ ^ ; ['copy-Literal']
copynode 0:  root operator-operator ||_ter ^ ^  ^ ^ ; ['copy-operator']
copynode 0:  root IfStatement ^ ^ ; ['root -> IfStatement']
copynode 0:  root StatementExpression ^ ^ ; ['root -> StatementExpression']
copynode 0:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  ^ ^ ; ['copy-MemberReference']
copynode 0:  root ReturnStatement ^ ^ ; ['root -> ReturnStatement']
copynode 0:  root modified ^ ^ ; ['root -> modified']
copynode 0:  root add ^ ^ ; ['root -> add']
copynode 0:  root ^ ; ['root -> End']
copynode 0:  root Literal-Literal value 30_ter ^ ^ ^  ^ ^ ; ['copy-Literal']
copynode 0:  root IfStatement ^ ^ ; ['root -> IfStatement']
copynode 0:  root StatementExpression ^ ^ ; ['root -> StatementExpression']
copynode 0:  root operator-operator <_ter ^ ^  ^ ^ ; ['copy-operator']
copynode 0:  root unknown ^ ^ ; ['start -> unknown']
copynode 0:  root ReturnStatement ^ ^ ; ['root -> ReturnStatement']
copynode 0:  root return_type ^ ^ ; ['root -> return_type']
before@1 batch0 x: -11.950498580932617: root ReturnStatement ^ ^  ; ['root -> ReturnStatement']
after@1 batch0 x: -11.950498580932617: root ReturnStatement ^ ^  ; ['root -> ReturnStatement']
before@1 batch1 x: -11.391855239868164: root return_type ^ ^  ; ['root -> return_type']
after@1 batch1 x: -11.391855239868164: root return_type ^ ^  ; ['root -> return_type']
copynode -0.004864165559411049:  root modified ^ operator-operator ||_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.004864165559411049:  root modified ^ operator-operator <_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.004864165559411049:  root modified ^ Literal-Literal value 500_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-Literal']
copynode -0.004864165559411049:  root modified ^ IfStatement ^ ^ ; ['root -> modified', 'root -> IfStatement']
copynode -0.004864165559411049:  root modified ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.004864165559411049:  root modified ^ MemberReference-MemberReference member loc4 ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.004864165559411049:  root modified ^ StatementExpression ^ ^ ; ['root -> modified', 'root -> StatementExpression']
copynode -5.611973285675049:  root add ^ IfStatement ^ ^ ; ['root -> add', 'root -> IfStatement']
copynode -5.611973285675049:  root add ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression']
copynode -0.004864165559411049:  root modified ^ operator-operator <_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.004864165559411049:  root modified ^ Literal-Literal value 500_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-Literal']
copynode -0.004864165559411049:  root modified ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value ^ ^ ^ ; ['copy-Literal', 'Literal -> value']
copynode -10.087299346923828:  root IfStatement condition ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  >=_ter ^ ^ ^ ; ['copy-operator', 'operator -> >=_ter']
copynode -10.513412475585938:  root StatementExpression expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  ||_ter ^ ^ ^ ; ['copy-operator', 'operator -> ||_ter']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  &&_ter ^ ^ ^ ; ['copy-operator', 'operator -> &&_ter']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> member']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  >_ter ^ ^ ^ ; ['copy-operator', 'operator -> >_ter']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -5.611973285675049:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter']
copynode -5.611973285675049:  root add ^ AssertStatement ^ ^ ; ['root -> add', 'root -> AssertStatement']
copynode -5.611973285675049:  root add ^ WhileStatement ^ ^ ; ['root -> add', 'root -> WhileStatement']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -11.950498580932617:  root ReturnStatement expression ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -5.611973285675049:  root add ^ LocalVariableDeclaration ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  <_ter ^ ^ ^ ; ['copy-operator', 'operator -> <_ter']
copynode -5.611973285675049:  root add ^ control ^ ^ ; ['root -> add', 'root -> control']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  <_ter ^ ^ ^ ; ['copy-operator', 'operator -> <_ter']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  prefix_operators ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> prefix_operators value']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  >_ter ^ ^ ^ ; ['copy-operator', 'operator -> >_ter']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -5.611973285675049:  root add ^ ReturnStatement ^ ^ ; ['root -> add', 'root -> ReturnStatement']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  -_ter ^ ^ ^ ; ['copy-operator', 'operator -> -_ter']
copynode -5.611973285675049:  root add ^ operator-operator ||_ter ^ ^  ^ ^ ; ['root -> add', 'copy-operator']
copynode -5.611973285675049:  root add ^ ^ ; ['root -> add', 'root -> End']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier member']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  >=_ter ^ ^ ^ ; ['copy-operator', 'operator -> >=_ter']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.513412475585938:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  +_ter ^ ^ ^ ; ['copy-operator', 'operator -> +_ter']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  selectors ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> selectors value']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value true_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  >>_ter ^ ^ ^ ; ['copy-operator', 'operator -> >>_ter']
copynode -9.569108963012695:  root operator-operator <_ter ^ ^  >>>_ter ^ ^ ^ ; ['copy-operator', 'operator -> >>>_ter']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value 500_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  +_ter ^ ^ ^ ; ['copy-operator', 'operator -> +_ter']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  prefix_operators ^ selectors ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> prefix_operators selectors value']
copynode -9.885825157165527:  root operator-operator ||_ter ^ ^  |_ter ^ ^ ^ ; ['copy-operator', 'operator -> |_ter']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> selectors member']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value true_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value 500_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value 500_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -9.769336700439453:  root Literal-Literal value 500_ter ^ ^ ^  value 500_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  postfix_operators ^ qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators qualifier member']
copynode -10.087299346923828:  root IfStatement unknown ^ ^ ^ ; ['root -> IfStatement', 'start -> unknown']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.823443412780762:  root MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  postfix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators selectors member']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 500_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.087299346923828:  root IfStatement condition ^ then_statement ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition then_statement']
copynode -10.087299346923828:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member SECOND_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -11.950498580932617:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.950498580932617:  root ReturnStatement loc0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.950498580932617:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.950498580932617:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.950498580932617:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.950498580932617:  root ReturnStatement unknown ^ ^ ^ ; ['root -> ReturnStatement', 'start -> unknown']
copynode -0.009673924185335636:  root modified ^ Literal-Literal value 30_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-Literal']
copynode -0.009673924185335636:  root modified ^ IfStatement ^ ^ ; ['root -> modified', 'root -> IfStatement']
copynode -0.009673924185335636:  root modified ^ operator-operator <_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -5.126012802124023:  root add ^ IfStatement ^ ^ ; ['root -> add', 'root -> IfStatement']
copynode -5.126012802124023:  root add ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression']
copynode -0.009673924185335636:  root modified ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.009673924185335636:  root modified ^ StatementExpression ^ ^ ; ['root -> modified', 'root -> StatementExpression']
copynode -0.009673924185335636:  root modified ^ operator-operator &&_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.009673924185335636:  root modified ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.009673924185335636:  root modified ^ operator-operator ||_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -0.009673924185335636:  root modified ^ MemberReference-MemberReference member loc4 ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value ^ ^ ^ ; ['copy-Literal', 'Literal -> value']
copynode -0.009673924185335636:  root modified ^ WhileStatement ^ ^ ; ['root -> modified', 'root -> WhileStatement']
copynode -9.191515922546387:  root IfStatement condition ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition']
copynode -9.496240615844727:  root StatementExpression expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  prefix_operators ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> prefix_operators value']
copynode -11.033088684082031:  root ReturnStatement expression ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -5.126012802124023:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter']
copynode -11.391855239868164:  root return_type ReferenceType ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType']
copynode -10.878926277160645:  root unknown ^ IfStatement ^ ^ ; ['start -> unknown', 'root -> IfStatement']
copynode -5.126012802124023:  root add ^ AssertStatement ^ ^ ; ['root -> add', 'root -> AssertStatement']
copynode -5.126012802124023:  root add ^ WhileStatement ^ ^ ; ['root -> add', 'root -> WhileStatement']
copynode -10.878926277160645:  root unknown ^ Literal-Literal value 30_ter ^ ^ ^  ^ ^ ; ['start -> unknown', 'copy-Literal']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -5.126012802124023:  root add ^ LocalVariableDeclaration ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration']
copynode -5.126012802124023:  root add ^ Literal-Literal value 30_ter ^ ^ ^  ^ ^ ; ['root -> add', 'copy-Literal']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  >=_ter ^ ^ ^ ; ['copy-operator', 'operator -> >=_ter']
copynode -5.126012802124023:  root add ^ control ^ ^ ; ['root -> add', 'root -> control']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  >_ter ^ ^ ^ ; ['copy-operator', 'operator -> >_ter']
copynode -5.126012802124023:  root add ^ ^ ; ['root -> add', 'root -> End']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  <_ter ^ ^ ^ ; ['copy-operator', 'operator -> <_ter']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -5.126012802124023:  root add ^ return_type ^ ^ ; ['root -> add', 'root -> return_type']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  selectors ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> selectors value']
copynode -11.391855239868164:  root return_type BasicType ^ ^ ^ ; ['root -> return_type', 'return_type -> BasicType']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value 1000L_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -10.878926277160645:  root unknown ^ StatementExpression ^ ^ ; ['start -> unknown', 'root -> StatementExpression']
copynode -9.496240615844727:  root StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  -_ter ^ ^ ^ ; ['copy-operator', 'operator -> -_ter']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value 1000L_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  prefix_operators ^ selectors ^ value ^ ^ ^ ; ['copy-Literal', 'Literal -> prefix_operators selectors value']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value 30_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -10.878926277160645:  root unknown ^ operator-operator <_ter ^ ^  ^ ^ ; ['start -> unknown', 'copy-operator']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  &_ter ^ ^ ^ ; ['copy-operator', 'operator -> &_ter']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value true_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value 30_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  >>_ter ^ ^ ^ ; ['copy-operator', 'operator -> >>_ter']
copynode -8.325715065002441:  root Literal-Literal value 30_ter ^ ^ ^  value 1000L_ter ^ ^ ^ ^ ; ['copy-Literal', 'copy-Literal']
copynode -10.617449760437012:  root operator-operator <_ter ^ ^  >>>_ter ^ ^ ^ ; ['copy-operator', 'operator -> >>>_ter']
copynode -10.878926277160645:  root unknown ^ control ^ ^ ; ['start -> unknown', 'root -> control']
copynode -10.878926277160645:  root unknown ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^  ^ ^ ; ['start -> unknown', 'copy-MemberReference']
copynode -10.878926277160645:  root unknown ^ ^ ; ['start -> unknown', 'root -> End']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.878926277160645:  root unknown ^ MemberReference-MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^  ^ ^ ; ['start -> unknown', 'copy-MemberReference']
copynode -10.878926277160645:  root unknown ^ AssertStatement ^ ^ ; ['start -> unknown', 'root -> AssertStatement']
copynode -10.878926277160645:  root unknown ^ operator-operator &&_ter ^ ^  ^ ^ ; ['start -> unknown', 'copy-operator']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.191515922546387:  root IfStatement unknown ^ ^ ^ ; ['root -> IfStatement', 'start -> unknown']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member done_ter ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference prefix_operators !_ter ^ ^ member round_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 30_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member time_ter ^ ^ ^ ^ value BinaryOperation operator -_ter ^ ^ operandl MemberReference member time_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr Literal value 1000L_ter ^ ^ ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.191515922546387:  root IfStatement condition ^ then_statement ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition then_statement']
copynode -9.191515922546387:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member field_ter ^ ^ ^ ^ operandr MemberReference qualifier Calendar_ter ^ ^ member MINUTE_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression Assignment expressionl MemberReference member done_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.496240615844727:  root StatementExpression unknown ^ ^ ^ ; ['root -> StatementExpression', 'start -> unknown']
copynode -11.033088684082031:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.391855239868164:  root return_type unknown ^ ^ ^ ; ['root -> return_type', 'start -> unknown']
copynode -11.033088684082031:  root ReturnStatement loc0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.033088684082031:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.033088684082031:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.033088684082031:  root ReturnStatement loc4 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-VariableDeclarator']
copynode -11.033088684082031:  root ReturnStatement unknown ^ ^ ^ ; ['root -> ReturnStatement', 'start -> unknown']
copynode -11.391855239868164:  root return_type loc0 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.391855239868164:  root return_type loc4 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.391855239868164:  root return_type loc4 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.391855239868164:  root return_type loc4 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.391855239868164:  root return_type loc4 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
before@2 batch0 x: -28.51885986328125: root ReturnStatement unknown ^ ^ ^  ; ['root -> ReturnStatement', 'start -> unknown']
after@2 batch0 x: -28.51885986328125: root ReturnStatement unknown ^ ^ ^  ; ['root -> ReturnStatement', 'start -> unknown']
before@2 batch1 x: -29.46099853515625: root return_type loc4 ^ ^ ^  ; ['root -> return_type', 'copy-VariableDeclarator']
stderr: Check out program version: Lang-53b........................................ OK
OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0
Running ant (export.dir.src.classes)....................................... OK

  0%|          | 0/1 [00:00<?, ?it/s]/root/projects/Recoder-bwk/run.py:527: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  tmpdepth = np.array(tmpdepth)
/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py:1340: UserWarning: nn.functional.tanh is deprecated. Use torch.tanh instead.
  warnings.warn("nn.functional.tanh is deprecated. Use torch.tanh instead.")
  0%|          | 0/1 [00:05<?, ?it/s]
Traceback (most recent call last):
  File "testDefect4j.py", line 638, in <module>
    ans = solveone(data, model)
  File "/root/projects/Recoder-bwk/run.py", line 1100, in solveone
    ans = BeamSearch((x[0], x[1], None, None, None, None, None, None, x[2], x[3]), dev_set, model, 100, args.batch_size, indexs)
  File "/root/projects/Recoder-bwk/run.py", line 541, in BeamSearch
    result = model(gVar(tmpnl), gVar(tmpnlad), gVar(tmprule), gVar(tmpruleparent), gVar(tmprulechild), gVar(tmpAd), gVar(tmptreepath), gVar(tmpnl8), gVar(tmpnl9), tmpf, tmpc, tmpindex, tmpchar, tmpindex2, rulead, antimasks, None, "test")
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 172, in forward
    genP1, _ = self.copy2(rulenoter.unsqueeze(0), decode)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 79, in forward
    genP = self.LinearRes(F.tanh(sourceLinear.unsqueeze(1) + targetLinear.unsqueeze(2))).squeeze(-1)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py", line 1341, in tanh
    return input.tanh()
RuntimeError: CUDA out of memory. Tried to allocate 1.81 GiB (GPU 0; 23.65 GiB total capacity; 2.65 GiB already allocated; 1007.31 MiB free; 3.59 GiB cached)
