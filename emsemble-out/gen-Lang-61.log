stdout: else_statement -> BlockStatement
using GPU
p
path org.apache.commons.lang.text.StrBuilder
indexOf
Position(line=1760, column=12)
FOUND IT!
[{'bugid': 'Lang-61', 'treeroot': <Searchnode.Node object at 0x7ff8a35690d0>, 'troot': <Searchnode.Node object at 0x7ff8a35690d0>, 'oldcode': '        int len = thisBuf.length - strLen;', 'filepath': 'buggy/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java', 'subroot': <Searchnode.Node object at 0x7ff8a34fe4d0>, 'vardic': {'indexOf_ter': 'meth0', 'str_ter': 'par0', 'startIndex_ter': 'par1', 'strLen_ter': 'loc0', 'thisBuf_ter': 'loc1', 'len_ter': 'loc2', 'i_ter': 'loc3', 'j_ter': 'loc4'}, 'typedic': {'str_ter': 'String', 'startIndex_ter': 'int', 'strLen_ter': 'int', 'thisBuf_ter': 'char', 'len_ter': 'int', 'i_ter': 'int', 'j_ter': 'int'}, 'idss': 'Lang-61', 'classname': 'org.apache.commons.lang.text.StrBuilder', 'precode': '/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.text;\n\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang.SystemUtils;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API\n * than StringBuffer.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n *  <ul>\n *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n *   <li>appendPadding - adds a length padding characters</li>\n *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n *   <li>delete - delete char or string</li>\n *   <li>replace - search and replace for a char or string</li>\n *   <li>leftString/rightString/midString - substring without exceptions</li>\n *   <li>contains - whether the builder contains a char or string</li>\n *   <li>size/clear/isEmpty - collections style API methods</li>\n *  </ul>\n * </li>\n * </ul>\n * <li>Views\n *  <ul>\n *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n *  </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer\n * provides, but with additional methods. It should be noted that some edge cases,\n * with invalid indices or null input, have been altered - see individual methods.\n * The biggest of these changes is that by default, null will not output the text\n * \'null\'. This can be controlled by a property, {@link #setNullText(String)}.\n *\n * @author Stephen Colebourne\n * @since 2.2\n * @version $Id$\n */\npublic class StrBuilder implements Cloneable {\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 7628716375283629643L;\n\n    /** Internal data storage. */\n    protected char[] buffer;\n    /** Current size of the buffer. */\n    protected int size;\n    /** The new line. */\n    private String newLine;\n    /** The null text. */\n    private String nullText;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that creates an empty builder initial capacity 32 characters.\n     */\n    public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructor that creates an empty builder the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n     */\n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    /**\n     * Constructor that creates a builder from the string, allocating\n     * 32 extra characters for growth.\n     *\n     * @param str  the string to copy, null treated as blank string\n     */\n    public StrBuilder(String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine  the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNewLineText(String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText  the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.length() == 0) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters\n     * or adding filler of unicode zero.\n     *\n     * @param length  the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public StrBuilder setLength(int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            int oldEnd = size;\n            int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = \'\\0\';\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Checks the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity  the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public StrBuilder ensureCapacity(int capacity) {\n        if (capacity > buffer.length) {\n            char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return the length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return <code>true</code> if the size is <code>0</code>.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer.\n     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero\n     * and is provided to match the API of Collections.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index  the index to retrieve, must be valid\n     * @return the character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public char charAt(int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index  the index to set\n     * @param ch  the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder setCharAt(int index, char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index  the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder deleteCharAt(int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Copies the builder\'s character array into a new character array.\n     * \n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        if (size == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[size];\n        System.arraycopy(buffer, 0, chars, 0, size);\n        return chars;\n    }\n\n    /**\n     * Copies part of the builder\'s character array into a new character array.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except that\n     *  if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid,\n     *  or if endIndex is invalid (but endIndex greater than size is valid)\n     */\n    public char[] toCharArray(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     * \n     * @param destination  the destination array, null will cause an array to be created\n     * @return the input array, unless that was null or too small\n     */\n    public char[] getChars(char[] destination) {\n        int len = length();\n        if (destination == null || destination.length < len) {\n            destination = new char[len];\n        }\n        System.arraycopy(buffer, 0, destination, 0, len);\n        return destination;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     *\n     * @param startIndex  first index to copy, inclusive, must be valid\n     * @param endIndex  last index, exclusive, must be valid\n     * @param destination  the destination array, must not be null or too small\n     * @param destinationIndex  the index to start copying in destination\n     * @throws NullPointerException if the array is null\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException("end < start");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}.\n     * This might be used to force the output to always use Unix line endings\n     * even when on Windows.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNewLine() {\n        if (newLine == null)  {\n            append(SystemUtils.LINE_SEPARATOR);\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing <code>null</code> to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNull() {\n        if (nullText == null)  {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends an object to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param obj  the object to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(Object obj) {\n        if (obj == null) {\n            return appendNull();\n        } \n        return append(obj.toString());        \n    }\n\n    /**\n     * Appends a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(String str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(String str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException("startIndex must be valid");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException("length must be valid");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string buffer to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StringBuffer str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException("startIndex must be valid");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException("length must be valid");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends another string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StrBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException("startIndex must be valid");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException("length must be valid");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        int strLen = chars.length;\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char[] chars, int startIndex, int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException("Invalid startIndex: " + length);\n        }\n        if (length < 0 || (startIndex + length) > chars.length) {\n            throw new StringIndexOutOfBoundsException("Invalid length: " + length);\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(boolean value) {\n        if (value) {\n            ensureCapacity(size + 4);\n            buffer[size++] = \'t\';\n            buffer[size++] = \'r\';\n            buffer[size++] = \'u\';\n            buffer[size++] = \'e\';\n        } else {\n            ensureCapacity(size + 5);\n            buffer[size++] = \'f\';\n            buffer[size++] = \'a\';\n            buffer[size++] = \'l\';\n            buffer[size++] = \'s\';\n            buffer[size++] = \'e\';\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char ch) {\n        int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends an int value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a double value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(double value) {\n        return append(String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an array placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param array  the array to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n        if (array != null && array.length > 0) {\n            separator = (separator == null ? "" : separator);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(separator);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a collection placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null collection will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param coll  the collection to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n        if (coll != null && coll.size() > 0) {\n            separator = (separator == null ? "" : separator);\n            Iterator it = coll.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null iterator will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param it  the iterator to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Iterator it, String separator) {\n        if (it != null) {\n            separator = (separator == null ? "" : separator);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     * \n     * @param length  the length to append, negative means no append\n     * @param padChar  the character to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendPadding(int length, char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the formatted value is larger than the length, the left hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inserts the string representation of an object into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param obj  the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param str  the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        int strLen = (str == null ? 0 : str.length());\n        if (strLen > 0) {\n            int newSize = size + strLen;\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n            size = newSize;\n            str.getChars(0, strLen, buffer, index);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, char chars[]) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @param offset  the offset into the character array to start at, must be valid\n     * @param length  the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public StrBuilder insert(int index, char chars[], int offset, int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException("Invalid offset: " + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException("Invalid length: " + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = \'t\';\n            buffer[index++] = \'r\';\n            buffer[index++] = \'u\';\n            buffer[index] = \'e\';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = \'f\';\n            buffer[index++] = \'a\';\n            buffer[index++] = \'l\';\n            buffer[index++] = \'s\';\n            buffer[index] = \'e\';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(int startIndex, int endIndex, int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behaviour.\n     * For example you could write a matcher to delete\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr  the string to replace with, null means delete range\n     * @param insertLen  the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n        int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string.\n     * The length of the inserted string does not have to match the removed length.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceStr  the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search character with the replace character\n     * throughout the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search character with the\n     * replace character in the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace all occurances\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public StrBuilder replace(\n            StrMatcher matcher, String replaceStr,\n            int startIndex, int endIndex, int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character \'a\' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param from  the start index, must be valid\n     * @param to  the end index (exclusive), must be valid\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private StrBuilder replaceImpl(\n            StrMatcher matcher, String replaceStr,\n            int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     * \n     * @return this, to enable chaining\n     */\n    public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n        \n        int half = size / 2;\n        char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n            char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Trims the builder by removing characters less than or equal to a space\n     * from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= \' \') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= \' \') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * \n     * @param str  the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * \n     * @param str  the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++,pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts a portion of this string builder as a string.\n     * \n     * @param start  the start index, inclusive, must be valid\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the\n     * builder as equal to the length of the builder, and continues\n     * without error, unlike StringBuffer or String.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the left <code>length</code> characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * \n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String leftString(int length) {\n        if (length <= 0) {\n            return "";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, 0, length);\n        }\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the right <code>length</code> characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * \n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String rightString(int length) {\n        if (length <= 0) {\n            return "";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, size - length, length);\n        }\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts <code>length</code> characters from the builder\n     * at the specified index.\n     * If the index is negative it is treated as zero.\n     * If the index is greater than the builder size, it is treated as the builder size.\n     * If the length is negative, the empty string is returned.\n     * If insufficient characters are available in the builder, as much as possible is returned.\n     * Thus the returned string may be shorter than the length requested.\n     * \n     * @param index  the index to start at, negative means zero\n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String midString(int index, int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return "";\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        } else {\n            return new String(buffer, index, length);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the string builder contains the specified string.\n     *\n     * @param str  the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Checks if the string builder contains a string matched using the\n     * specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to search for the character\n     * \'a\' followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @return the first index of the character, or -1 if not found\n     */\n    public int indexOf(char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;', 'aftercode': '        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character \'a\'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character \'a\'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        int len = size;\n        char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @return the last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(char ch, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @return the last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(String str, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer:\n            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n            \n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character \'a\'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the last index matched, or -1 if not found\n     */\n    public int lastIndexOf(StrMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character \'a\'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index matched, or -1 if not found\n     */\n    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        char[] buf = buffer;\n        int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized.\n     * The tokenizer will be setup by default to tokenize on space, tab,\n     * newline and formfeed (as per StringTokenizer). These values can be\n     * changed on the tokenizer class, before retrieving the tokens.\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix\n     * calls to the buider and tokenizer within certain limits, however\n     * there is no synchronization. Once the tokenizer has been used once,\n     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n     * changes in the builder. For example:\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append("a b ");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray();  // returns a,b\n     * b.append("c d ");\n     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n     * t.reset();              // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n     * </pre>\n     * In addition to simply intermixing appends and tokenization, you can also\n     * call the set methods on the tokenizer to alter how it tokenizes. Just\n     * remember to call reset when you want to pickup builder changes.\n     * <p>\n     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n     * with a non-null value will break the link with the builder.\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read\n     * using any standard method that expects a Reader.\n     * <p>\n     * To use, simply create a <code>StrBuilder</code>, populate it with\n     * data, call <code>asReader</code>, and then read away.\n     * <p>\n     * The internal character array is shared between the builder and the reader.\n     * This allows you to append to the builder after creating the reader,\n     * and the changes will be picked up.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the reader in one thread.\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new StrBuilderReader();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder\n     * using any standard method that takes a Writer.\n     * <p>\n     * To use, simply create a <code>StrBuilder</code>,\n     * call <code>asWriter</code>, and populate away. The data is available\n     * at any time using the methods of the <code>StrBuilder</code>.\n     * <p>\n     * The internal character array is shared between the builder and the writer.\n     * This allows you to intermix calls that append to the builder and\n     * write using the writer and the changes will be occur correctly.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the writer in one thread.\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new StrBuilderWriter();\n    }\n\n    //-----------------------------------------------------------------------\n//    /**\n//     * Gets a String version of the string builder by calling the internal\n//     * constructor of String by reflection.\n//     * <p>\n//     * WARNING: You must not use the StrBuilder after calling this method\n//     * as the buffer is now shared with the String object. To ensure this,\n//     * the internal character array is set to null, so you will get\n//     * NullPointerExceptions on all method calls.\n//     *\n//     * @return the builder as a String\n//     */\n//    public String toSharedString() {\n//        try {\n//            Constructor con = String.class.getDeclaredConstructor(\n//                new Class[] {int.class, int.class, char[].class});\n//            con.setAccessible(true);\n//            char[] buffer = buf;\n//            buf = null;\n//            size = -1;\n//            nullText = null;\n//            return (String) con.newInstance(\n//                new Object[] {new Integer(0), new Integer(size), buffer});\n//            \n//        } catch (Exception ex) {\n//            ex.printStackTrace();\n//            throw new UnsupportedOperationException("StrBuilder.toSharedString is unsupported: " + ex.getMessage());\n//        }\n//    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content ignoring case.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            char c1 = thisBuf[i];\n            char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof StrBuilder) {\n            return equals((StrBuilder) obj);\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    public int hashCode() {\n        char buf[] = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a String version of the string builder, creating a new instance\n     * each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is\n     * independent of the string builder.\n     *\n     * @return the builder as a String\n     */\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a\n     * new instance each time the method is called.\n     *\n     * @return the builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Validates parameters defining a range of the builder.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException("end < start");\n        }\n        return endIndex;\n    }\n\n    /**\n     * Validates parameters defining a single index in the builder.\n     * \n     * @param index  the index, must be valid\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void validateIndex(int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class StrBuilderTokenizer extends StrTokenizer {\n\n        /** {@inheritDoc} */\n        StrBuilderTokenizer() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        protected List tokenize(char[] chars, int offset, int count) {\n            if (chars == null) {\n                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            } else {\n                return super.tokenize(chars, offset, count);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public String getContent() {\n            String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            } else {\n                return str;\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class StrBuilderReader extends Reader {\n        /** The current stream position. */\n        private int pos;\n        /** The last mark position. */\n        private int mark;\n\n        /** {@inheritDoc} */\n        StrBuilderReader() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public int read() {\n            if (ready() == false) {\n                return -1;\n            }\n            return StrBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        public int read(char b[], int off, int len) {\n            if (off < 0 || len < 0 || off > b.length ||\n                    (off + len) > b.length || (off + len) < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= StrBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = StrBuilder.this.size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        public long skip(long n) {\n            if (pos + n > StrBuilder.this.size()) {\n                n = StrBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos += n;\n            return n;\n        }\n\n        /** {@inheritDoc} */\n        public boolean ready() {\n            return pos < StrBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        public void mark(int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        public void reset() {\n            pos = mark;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class StrBuilderWriter extends Writer {\n\n        /** {@inheritDoc} */\n        StrBuilderWriter() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public void write(int c) {\n            StrBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        public void write(char[] cbuf) {\n            StrBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        public void write(char[] cbuf, int off, int len) {\n            StrBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        public void write(String str) {\n            StrBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        public void write(String str, int off, int len) {\n            StrBuilder.this.append(str, off, len);\n        }\n    }\n\n}', 'tree': 'MethodDeclaration modifiers public_ter ^ ^ return_type BasicType name int_ter ^ ^ ^ ^ name meth0 ^ ^ parameters FormalParameter type ReferenceType name String_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par1 ^ ^ ^ ^ body StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par0 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier par0 ^ ^ member length_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 1_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MethodInvocation arguments MethodInvocation qualifier par0 ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member charAt_ter ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator >_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name char_ter ^ ^ dimensions None_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer MemberReference member buffer_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer BinaryOperation operator -_ter ^ ^ operandl MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^ ^ operandr MemberReference member loc0 ^ ^ ^ ^ ^ ^ ^ ^ ^ ForStatement label outer_ter ^ ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc2 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc3 ^ ^ ^ ^ ^ ^ body BlockStatement statements ForStatement control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr MemberReference member loc0 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc4 ^ ^ ^ ^ ^ ^ body BlockStatement statements IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MethodInvocation qualifier par0 ^ ^ arguments MemberReference member loc4 ^ ^ ^ ^ member charAt_ter ^ ^ ^ ^ operandr MemberReference selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member loc1 ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ContinueStatement goto outer_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ^ ^ ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ', 'prob': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 'mode': 0, 'line': 1776, 'isa': False, 'fl_score': 1}]
before@0 batch0 x: 0: root ^  ; []
after@0 batch0 x: 0: root ^  ; []
copynode 0:  root modified ^ ^ ; ['root -> modified']
copynode 0:  root add ^ ^ ; ['root -> add']
copynode 0:  root ^ ; ['root -> End']
copynode 0:  root return_type ^ ^ ; ['root -> return_type']
copynode 0:  root ReturnStatement ^ ^ ; ['root -> ReturnStatement']
copynode 0:  root StatementExpression ^ ^ ; ['root -> StatementExpression']
copynode 0:  root IfStatement ^ ^ ; ['root -> IfStatement']
copynode 0:  root parameters ^ ^ ; ['root -> parameters']
copynode 0:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  ^ ^ ; ['copy-MemberReference']
copynode 0:  root operator-operator -_ter ^ ^  ^ ^ ; ['copy-operator']
before@1 batch0 x: -12.039507865905762: root operator-operator -_ter ^ ^  ^ ^  ; ['copy-operator']
after@1 batch0 x: -12.039507865905762: root operator-operator -_ter ^ ^  ^ ^  ; ['copy-operator']
copynode -0.2420690804719925:  root modified ^ LocalVariableDeclaration ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration']
copynode -0.2420690804719925:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -1.5396573543548584:  root add ^ IfStatement ^ ^ ; ['root -> add', 'root -> IfStatement']
copynode -0.2420690804719925:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-MemberReference']
copynode -0.2420690804719925:  root modified ^ operator-operator -_ter ^ ^  ^ ^ ; ['root -> modified', 'copy-operator']
copynode -1.5396573543548584:  root add ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression']
copynode -0.2420690804719925:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  ^ ^ ; ['root -> modified', 'copy-BasicType']
copynode -0.2420690804719925:  root modified ^ StatementExpression ^ ^ ; ['root -> modified', 'root -> StatementExpression']
copynode -1.5396573543548584:  root add ^ ReturnStatement ^ ^ ; ['root -> add', 'root -> ReturnStatement']
copynode -1.5396573543548584:  root add ^ LocalVariableDeclaration ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration']
copynode -1.5396573543548584:  root add ^ control ^ ^ ; ['root -> add', 'root -> control']
copynode -0.2420690804719925:  root modified ^ control ^ ^ ; ['root -> modified', 'root -> control']
copynode -0.2420690804719925:  root modified ^ ^ ; ['root -> modified', 'root -> End']
copynode -1.5396573543548584:  root add ^ WhileStatement ^ ^ ; ['root -> add', 'root -> WhileStatement']
copynode -1.5396573543548584:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter']
copynode -1.5396573543548584:  root add ^ AssertStatement ^ ^ ; ['root -> add', 'root -> AssertStatement']
copynode -1.5396573543548584:  root add ^ BreakStatement_ter ^ ^ ; ['root -> add', 'root -> BreakStatement_ter']
copynode -0.2420690804719925:  root modified ^ ReturnStatement ^ ^ ; ['root -> modified', 'root -> ReturnStatement']
copynode -0.2420690804719925:  root modified ^ parameters ^ ^ ; ['root -> modified', 'root -> parameters']
copynode -9.23427963256836:  root return_type ReferenceType ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType']
copynode -1.5396573543548584:  root add ^ Statement_ter ^ ^ ; ['root -> add', 'root -> Statement_ter']
copynode -10.068485260009766:  root StatementExpression expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression']
copynode -10.175422668457031:  root IfStatement condition ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition']
copynode -9.760725021362305:  root ReturnStatement expression ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -9.23427963256836:  root return_type BasicType ^ ^ ^ ; ['root -> return_type', 'return_type -> BasicType']
copynode -11.022359848022461:  root parameters FormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> FormalParameter']
copynode -9.760725021362305:  root ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -9.760725021362305:  root ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -9.760725021362305:  root ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> member']
copynode -9.760725021362305:  root ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  -_ter ^ ^ ^ ; ['copy-operator', 'operator -> -_ter']
copynode -10.068485260009766:  root StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> StatementExpression', 'copy-StatementExpression']
copynode -9.760725021362305:  root ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -9.760725021362305:  root ReturnStatement expression MethodInvocation arguments MethodInvocation qualifier par0 ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member charAt_ter ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier member']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  +_ter ^ ^ ^ ; ['copy-operator', 'operator -> +_ter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  /_ter ^ ^ ^ ; ['copy-operator', 'operator -> /_ter']
copynode -11.022359848022461:  root parameters ^ ^ ; ['root -> parameters', 'parameters -> End']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  *_ter ^ ^ ^ ; ['copy-operator', 'operator -> *_ter']
copynode -9.23427963256836:  root return_type BasicType name int_ter ^ ^ ^ ^ ^ ; ['root -> return_type', 'copy-return_type']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  %_ter ^ ^ ^ ; ['copy-operator', 'operator -> %_ter']
copynode -11.022359848022461:  root parameters MemberReference ^ ^ ^ ; ['root -> parameters', 'parameters -> MemberReference']
copynode -11.022359848022461:  root parameters FormalParameter type ReferenceType name String_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type BasicType name int_ter ^ ^ ^ ^ name par1 ^ ^ ^ ^ ^ ; ['root -> parameters', 'copy-parameters']
copynode -11.022359848022461:  root parameters InferredFormalParameter ^ ^ ^ ; ['root -> parameters', 'parameters -> InferredFormalParameter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  ==_ter ^ ^ ^ ; ['copy-operator', 'operator -> ==_ter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  !=_ter ^ ^ ^ ; ['copy-operator', 'operator -> !=_ter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  |_ter ^ ^ ^ ; ['copy-operator', 'operator -> |_ter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  <=_ter ^ ^ ^ ; ['copy-operator', 'operator -> <=_ter']
copynode -12.039507865905762:  root operator-operator -_ter ^ ^  &_ter ^ ^ ^ ; ['copy-operator', 'operator -> &_ter']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> selectors member']
copynode -9.23427963256836:  root return_type par0 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -10.175422668457031:  root IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MethodInvocation qualifier par0 ^ ^ arguments MemberReference member loc4 ^ ^ ^ ^ member charAt_ter ^ ^ ^ ^ operandr MemberReference selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member loc1 ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ContinueStatement goto outer_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -9.23427963256836:  root return_type par1 ^ ^ ^ ; ['root -> return_type', 'copy-FormalParameter']
copynode -10.175422668457031:  root IfStatement condition BinaryOperation operator >_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.175422668457031:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -10.175422668457031:  root IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 1_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MethodInvocation arguments MethodInvocation qualifier par0 ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member charAt_ter ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -10.175422668457031:  root IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par0 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> IfStatement', 'copy-IfStatement']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -9.23427963256836:  root return_type unknown ^ ^ ^ ; ['root -> return_type', 'start -> unknown']
copynode -11.022359848022461:  root parameters Cast ^ ^ ^ ; ['root -> parameters', 'parameters -> Cast']
copynode -9.760725021362305:  root ReturnStatement par1 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -11.022359848022461:  root parameters loc0 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -10.068485260009766:  root StatementExpression par1 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -10.068485260009766:  root StatementExpression unknown ^ ^ ^ ; ['root -> StatementExpression', 'start -> unknown']
copynode -9.760725021362305:  root ReturnStatement par0 ^ ^ ^ ; ['root -> ReturnStatement', 'copy-FormalParameter']
copynode -10.068485260009766:  root StatementExpression par0 ^ ^ ^ ; ['root -> StatementExpression', 'copy-FormalParameter']
copynode -11.022359848022461:  root parameters loc1 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -10.175422668457031:  root IfStatement par1 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -10.175422668457031:  root IfStatement par0 ^ ^ ^ ; ['root -> IfStatement', 'copy-FormalParameter']
copynode -11.022359848022461:  root parameters loc4 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -11.022359848022461:  root parameters loc3 ^ ^ ^ ; ['root -> parameters', 'copy-VariableDeclarator']
copynode -10.175422668457031:  root IfStatement condition ^ then_statement ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition then_statement']
copynode -10.175422668457031:  root IfStatement unknown ^ ^ ^ ; ['root -> IfStatement', 'start -> unknown']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ qualifier ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> prefix_operators qualifier selectors member']
copynode -9.23427963256836:  root return_type loc0 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -9.23427963256836:  root return_type loc4 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -9.23427963256836:  root return_type loc1 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -9.23427963256836:  root return_type loc3 ^ ^ ^ ; ['root -> return_type', 'copy-VariableDeclarator']
copynode -11.846212387084961:  root MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  postfix_operators ^ selectors ^ member ^ ^ ^ ; ['copy-MemberReference', 'MemberReference -> postfix_operators selectors member']
copynode -9.760725021362305:  root ReturnStatement unknown ^ ^ ^ ; ['root -> ReturnStatement', 'start -> unknown']
copynode -10.068485260009766:  root StatementExpression loc3 ^ ^ ^ ; ['root -> StatementExpression', 'copy-VariableDeclarator']
copynode -10.068485260009766:  root StatementExpression label ^ expression ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> label expression']
copynode -10.068485260009766:  root StatementExpression loc2 ^ ^ ^ ; ['root -> StatementExpression', 'copy-VariableDeclarator']
copynode -10.068485260009766:  root StatementExpression loc4 ^ ^ ^ ; ['root -> StatementExpression', 'copy-VariableDeclarator']
copynode -10.068485260009766:  root StatementExpression loc1 ^ ^ ^ ; ['root -> StatementExpression', 'copy-VariableDeclarator']
before@2 batch0 x: -28.750280380249023: root StatementExpression loc1 ^ ^ ^  ; ['root -> StatementExpression', 'copy-VariableDeclarator']
after@2 batch0 x: -28.750280380249023: root StatementExpression loc1 ^ ^ ^  ; ['root -> StatementExpression', 'copy-VariableDeclarator']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration type ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> type declarators']
copynode -1.8951464593410492:  root add ^ IfStatement condition ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member']
copynode -2.8536616563796997:  root add ^ StatementExpression expression ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'StatementExpression -> expression']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  -_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> -_ter']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'BasicType -> name']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  <=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> <=_ter']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  >=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >=_ter']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  +_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> +_ter']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  ==_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> ==_ter']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name char_ter ^ ^ dimensions None_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration modifiers ^ type ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> modifiers type declarators']
copynode -2.8536616563796997:  root add ^ StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'copy-StatementExpression']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  /_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> /_ter']
copynode -5.910639122128487:  root modified ^ StatementExpression expression ^ ^ ^ ; ['root -> modified', 'root -> StatementExpression', 'StatementExpression -> expression']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  %_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> %_ter']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  >_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >_ter']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  >>_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >>_ter']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -2.545384958386421:  root modified ^ operator-operator -_ter ^ ^  !=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> !=_ter']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member']
copynode -6.546593904495239:  root add ^ LocalVariableDeclaration type ^ declarators ^ ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> type declarators']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member']
copynode -6.102761507034302:  root add ^ ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier par0 ^ ^ member length_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'copy-LocalVariableDeclaration']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member']
copynode -7.046870544552803:  root modified ^ control EnhancedForControl ^ ^ ^ ; ['root -> modified', 'root -> control', 'control -> EnhancedForControl']
copynode -6.993811845779419:  root add ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr MemberReference member loc0 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc4 ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> control', 'copy-control']
copynode -6.102761507034302:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -7.697936296463013:  root add ^ WhileStatement condition ^ ^ ^ ; ['root -> add', 'root -> WhileStatement', 'WhileStatement -> condition']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -6.993811845779419:  root add ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc2 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc3 ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> control', 'copy-control']
copynode -7.046870544552803:  root modified ^ control ForControl ^ ^ ^ ; ['root -> modified', 'root -> control', 'control -> ForControl']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -6.102761507034302:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -8.166621446609497:  root add ^ ReturnStatement_ter ^ ^ ; ['root -> add', 'root -> ReturnStatement_ter', 'root -> End']
copynode -6.102761507034302:  root add ^ ReturnStatement expression ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -8.45776104927063:  root add ^ BreakStatement_ter ^ ^ ; ['root -> add', 'root -> BreakStatement_ter', 'root -> End']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  postfix_operators ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> postfix_operators member']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType']
copynode -6.546593904495239:  root add ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier par0 ^ ^ member length_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration', 'copy-LocalVariableDeclaration']
copynode -6.102761507034302:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -8.213181734085083:  root add ^ AssertStatement condition ^ ^ ^ ; ['root -> add', 'root -> AssertStatement', 'AssertStatement -> condition']
copynode -6.102761507034302:  root add ^ ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -8.608538463711739:  root modified ^ ReturnStatement expression ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'ReturnStatement -> expression']
copynode -3.7869773656129837:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name ^ dimensions ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'BasicType -> name dimensions']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration annotations ^ type ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> annotations type declarators']
copynode -9.072345569729805:  root modified ^ parameters FormalParameter ^ ^ ^ ; ['root -> modified', 'root -> parameters', 'parameters -> FormalParameter']
copynode -6.993811845779419:  root add ^ control EnhancedForControl ^ ^ ^ ; ['root -> add', 'root -> control', 'control -> EnhancedForControl']
copynode -9.461093187332153:  root add ^ Statement_ter ^ ^ ; ['root -> add', 'root -> Statement_ter', 'root -> End']
copynode -6.102761507034302:  root add ^ ReturnStatement expression MethodInvocation arguments MethodInvocation qualifier par0 ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member charAt_ter ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -5.910639122128487:  root modified ^ StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> StatementExpression', 'copy-StatementExpression']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration type BasicType name char_ter ^ ^ dimensions None_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer MemberReference member buffer_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'copy-LocalVariableDeclaration']
copynode -6.993811845779419:  root add ^ control ForControl ^ ^ ^ ; ['root -> add', 'root -> control', 'control -> ForControl']
copynode -9.459067165851593:  root return_type ReferenceType name String_ter ^ ^ ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType', 'copy-ReferenceType']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier ^ selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier selectors member']
copynode -10.176389804109931:  root IfStatement condition BinaryOperation ^ ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition', 'condition -> BinaryOperation']
copynode -6.546593904495239:  root add ^ LocalVariableDeclaration type BasicType name char_ter ^ ^ dimensions None_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer MemberReference member buffer_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration', 'copy-LocalVariableDeclaration']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators ^ qualifier ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators qualifier member']
copynode -10.145957380533218:  root StatementExpression expression MethodInvocation ^ ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression', 'expression -> MethodInvocation']
copynode -7.046870544552803:  root modified ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr MemberReference member loc0 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc4 ^ ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> control', 'copy-control']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration par0 ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'copy-FormalParameter']
copynode -1.8951464593410492:  root add ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MethodInvocation qualifier par0 ^ ^ arguments MemberReference member loc4 ^ ^ ^ ^ member charAt_ter ^ ^ ^ ^ operandr MemberReference selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member loc1 ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ContinueStatement goto outer_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'copy-IfStatement']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration par1 ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'copy-FormalParameter']
copynode -10.145957380533218:  root StatementExpression expression Assignment ^ ^ ^ ^ ; ['root -> StatementExpression', 'StatementExpression -> expression', 'expression -> Assignment']
copynode -1.8951464593410492:  root add ^ IfStatement condition BinaryOperation operator >_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'copy-IfStatement']
copynode -1.8951464593410492:  root add ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 1_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MethodInvocation arguments MethodInvocation qualifier par0 ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member charAt_ter ^ ^ ^ MemberReference member par1 ^ ^ ^ ^ member meth0 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'copy-IfStatement']
copynode -1.8951464593410492:  root add ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'copy-IfStatement']
copynode -11.505239248275757:  root ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -8.608538463711739:  root modified ^ ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -7.046870544552803:  root modified ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc2 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc3 ^ ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> control', 'copy-control']
copynode -10.733426570892334:  root ReturnStatement expression Literal ^ ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression', 'expression -> Literal']
copynode -11.549596548080444:  root ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -8.608538463711739:  root modified ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -1.4935383349657059:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -1.8951464593410492:  root add ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par0 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'copy-IfStatement']
copynode -9.459067165851593:  root return_type ReferenceType name ^ arguments ^ ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType', 'ReferenceType -> name arguments']
copynode -8.608538463711739:  root modified ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -11.718352913856506:  root ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -6.546593904495239:  root add ^ LocalVariableDeclaration modifiers ^ type ^ declarators ^ ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> modifiers type declarators']
copynode -10.176389804109931:  root IfStatement condition MethodInvocation ^ ^ ^ ^ ; ['root -> IfStatement', 'IfStatement -> condition', 'condition -> MethodInvocation']
copynode -11.091909296810627:  root parameters FormalParameter type ^ name ^ ^ ^ ^ ; ['root -> parameters', 'parameters -> FormalParameter', 'FormalParameter -> type name']
copynode -10.733426570892334:  root ReturnStatement expression MemberReference ^ ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression', 'expression -> MemberReference']
copynode -1.1704964190721512:  root modified ^ LocalVariableDeclaration modifiers ^ annotations ^ type ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> modifiers annotations type declarators']
copynode -1.9456476718187332:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators ^ selectors ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators selectors member']
copynode -9.459067165851593:  root return_type ReferenceType name ^ ^ ^ ^ ; ['root -> return_type', 'return_type -> ReferenceType', 'ReferenceType -> name']
copynode -11.091909296810627:  root parameters FormalParameter modifiers ^ type ^ name ^ ^ ^ ^ ; ['root -> parameters', 'parameters -> FormalParameter', 'FormalParameter -> modifiers type name']
copynode -10.733426570892334:  root ReturnStatement expression BinaryOperation ^ ^ ^ ^ ; ['root -> ReturnStatement', 'ReturnStatement -> expression', 'expression -> BinaryOperation']
copynode -8.608538463711739:  root modified ^ ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
before@3 batch0 x: -12.46002371609211: root modified ^ ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^  ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
after@3 batch0 x: -12.46002371609211: root modified ^ ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^  ; ['root -> modified', 'root -> ReturnStatement', 'copy-ReturnStatement']
copynode -1.1883144825696945:  root modified ^ LocalVariableDeclaration type BasicType ^ ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> type declarators', 'type -> BasicType']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'condition -> BinaryOperation']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier loc1 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc1']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member loc1 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc1']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member loc1 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc1']
copynode -3.4113583117723465:  root modified ^ operator-operator -_ter ^ ^  -_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> -_ter', 'root -> End']
copynode -2.9384734854102135:  root add ^ StatementExpression expression MethodInvocation ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> MethodInvocation']
copynode -1.8960220771841705:  root add ^ IfStatement condition MethodInvocation ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'condition -> MethodInvocation']
copynode -2.9384734854102135:  root add ^ StatementExpression expression Assignment ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> Assignment']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member loc0 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc0']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member loc0 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc0']
copynode -4.475997164845467:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier loc1 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc1']
copynode -4.646416023373604:  root modified ^ operator-operator -_ter ^ ^  <=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> <=_ter', 'root -> End']
copynode -4.6908536702394485:  root modified ^ operator-operator -_ter ^ ^  >=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >=_ter', 'root -> End']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member loc2 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc2']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member loc2 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc2']
copynode -4.490257158875465:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name long_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'BasicType -> name', 'name -> long_ter']
copynode -1.8960220771841705:  root add ^ IfStatement condition MemberReference ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'condition -> MemberReference']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member unknown ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'start -> unknown']
copynode -5.223269060254097:  root modified ^ operator-operator -_ter ^ ^  +_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> +_ter', 'root -> End']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member unknown ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'start -> unknown']
copynode -5.369978502392769:  root modified ^ operator-operator -_ter ^ ^  ==_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> ==_ter', 'root -> End']
copynode -5.393688037991524:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name char_ter ^ ^ dimensions None_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member par0 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> par0']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member buffer_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'copy-member']
copynode -5.447525933384895:  root modified ^ LocalVariableDeclaration modifiers final_ter ^ ^ type ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> modifiers type declarators', 'modifiers -> final_ter']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member par0 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> par0']
copynode -4.490257158875465:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'BasicType -> name', 'name -> int_ter']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member par1 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> par1']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member buffer_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'copy-member']
copynode -5.4644612073898315:  root add ^ StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'copy-StatementExpression', 'root -> End']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member loc3 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc3']
copynode -5.8283751755952835:  root modified ^ operator-operator -_ter ^ ^  /_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> /_ter', 'root -> End']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member size_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'copy-member']
copynode -2.9384734854102135:  root add ^ StatementExpression expression MemberReference ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> MemberReference']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier loc0 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc0']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member loc3 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc3']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member par1 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> par1']
copynode -6.108990028500557:  root modified ^ operator-operator -_ter ^ ^  %_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> %_ter', 'root -> End']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier unknown ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'start -> unknown']
copynode -2.046088382601738:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  member size_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'copy-member']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member size_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'copy-member']
copynode -6.179275348782539:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -6.232055500149727:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -6.372938707470894:  root modified ^ operator-operator -_ter ^ ^  >_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >_ter', 'root -> End']
copynode -6.385410621762276:  root modified ^ operator-operator -_ter ^ ^  >>_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> >>_ter', 'root -> End']
copynode -6.414871051907539:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -5.937702002003789:  root modified ^ StatementExpression expression Assignment ^ ^ ^ ^ ; ['root -> modified', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> Assignment']
copynode -6.482258394360542:  root modified ^ operator-operator -_ter ^ ^  !=_ter ^ ^ ^ ; ['root -> modified', 'copy-operator', 'operator -> !=_ter', 'root -> End']
copynode -1.1883144825696945:  root modified ^ LocalVariableDeclaration type ReferenceType ^ ^ declarators ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> type declarators', 'type -> ReferenceType']
copynode -2.2051439434289932:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  member loc4 ^ ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> member', 'member -> loc4']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier par0 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> par0']
copynode -6.7204117476940155:  root add ^ LocalVariableDeclaration type BasicType ^ ^ declarators ^ ^ ^ ; ['root -> add', 'root -> LocalVariableDeclaration', 'LocalVariableDeclaration -> type declarators', 'type -> BasicType']
copynode -6.620706036686897:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators -_ter ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member', 'prefix_operators -> -_ter']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier loc2 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc2']
copynode -6.644600823521614:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators -_ter ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member', 'prefix_operators -> -_ter']
copynode -7.076556444168091:  root add ^ ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -5.937702002003789:  root modified ^ StatementExpression expression MethodInvocation ^ ^ ^ ^ ; ['root -> modified', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> MethodInvocation']
copynode -7.27354522049427:  root modified ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier par0 ^ ^ member length_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> modified', 'root -> LocalVariableDeclaration', 'copy-LocalVariableDeclaration', 'root -> End']
copynode -6.89466567337513:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  selectors ArraySelector ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member', 'selectors -> ArraySelector']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MethodInvocation qualifier par0 ^ ^ arguments MemberReference member loc4 ^ ^ ^ ^ member charAt_ter ^ ^ ^ ^ operandr MemberReference selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member loc1 ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -7.569196835160255:  root modified ^ control EnhancedForControl var ^ iterable ^ ^ ^ ^ ; ['root -> modified', 'root -> control', 'control -> EnhancedForControl', 'EnhancedForControl -> var iterable']
copynode -4.475997164845467:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier loc0 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc0']
copynode -7.749465227127075:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -5.4644612073898315:  root add ^ StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression ^ ^ ; ['root -> add', 'root -> StatementExpression', 'copy-StatementExpression', 'root -> StatementExpression']
copynode -6.89466567337513:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member', 'copy-selectors']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator >_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -7.942140653729439:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -8.0331040173769:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier loc3 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc3']
copynode -5.937702002003789:  root modified ^ StatementExpression expression MemberReference ^ ^ ^ ^ ; ['root -> modified', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> MemberReference']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value 1_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -5.4644612073898315:  root add ^ StatementExpression expression Assignment expressionl MemberReference member par1 ^ ^ ^ ^ value TernaryExpression condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ if_true Literal value 0_ter ^ ^ ^ ^ if_false MemberReference member par1 ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ IfStatement ^ ^ ; ['root -> add', 'root -> StatementExpression', 'copy-StatementExpression', 'root -> IfStatement']
copynode -7.5432786494493484:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  selectors ArraySelector ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member', 'selectors -> ArraySelector']
copynode -7.809361286461353:  root add ^ WhileStatement condition BinaryOperation ^ ^ ^ ^ ; ['root -> add', 'root -> WhileStatement', 'WhileStatement -> condition', 'condition -> BinaryOperation']
copynode -8.19427227973938:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -4.475997164845467:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier unknown ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'start -> unknown']
copynode -7.723211646080017:  root add ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc4 ^ ^ ^ ^ operandr MemberReference member loc0 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc4 ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> control', 'copy-control', 'root -> End']
copynode -7.5432786494493484:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  selectors ArraySelector index BinaryOperation operator +_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc4 ^ ^ ^ ^ ^ ^ ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> selectors member', 'copy-selectors']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value 0_ter ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -1.8960220771841705:  root add ^ IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ==_ter ^ ^ operandl MemberReference member par0 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr MemberReference member size_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> IfStatement', 'IfStatement -> condition', 'copy-condition']
copynode -8.071802452206612:  root modified ^ control ForControl init ^ condition ^ update ^ ^ ^ ^ ; ['root -> modified', 'root -> control', 'control -> ForControl', 'ForControl -> init condition update']
copynode -2.9384734854102135:  root add ^ StatementExpression expression This ^ ^ ^ ^ ; ['root -> add', 'root -> StatementExpression', 'StatementExpression -> expression', 'expression -> This']
copynode -8.03628385066986:  root add ^ control ForControl init VariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MemberReference member par1 ^ ^ ^ ^ ^ ^ ^ ^ condition BinaryOperation operator <_ter ^ ^ operandl MemberReference member loc3 ^ ^ ^ ^ operandr MemberReference member loc2 ^ ^ ^ ^ ^ ^ update MemberReference postfix_operators ++_ter ^ ^ member loc3 ^ ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> control', 'copy-control', 'root -> End']
copynode -8.131489709019661:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  postfix_operators ++_ter ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> postfix_operators member', 'copy-postfix_operators']
copynode -8.586624220013618:  root modified ^ BasicType-BasicType name int_ter ^ ^ ^  name int_ter ^ ^ ^ ^ ; ['root -> modified', 'copy-BasicType', 'copy-BasicType', 'root -> End']
copynode -6.644600823521614:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  prefix_operators ~_ter ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member', 'prefix_operators -> ~_ter']
copynode -8.649632692337036:  root add ^ ReturnStatement expression Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -2.194447472691536:  root modified ^ MemberReference-MemberReference qualifier loc1 ^ ^ member length_ter ^ ^ ^  qualifier loc1 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'copy-qualifier']
copynode -8.670632600784302:  root add ^ ReturnStatement expression MemberReference member par1 ^ ^ ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'copy-ReturnStatement', 'root -> End']
copynode -4.475997164845467:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier par0 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> par0']
copynode -8.247369289398193:  root add ^ ReturnStatement expression Literal ^ ^ ^ ^ ; ['root -> add', 'root -> ReturnStatement', 'ReturnStatement -> expression', 'expression -> Literal']
copynode -4.475997164845467:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  qualifier loc2 ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> qualifier member', 'qualifier -> loc2']
copynode -8.812772706151009:  root modified ^ ReturnStatement expression BinaryOperation ^ ^ ^ ^ ; ['root -> modified', 'root -> ReturnStatement', 'ReturnStatement -> expression', 'expression -> BinaryOperation']
copynode -6.620706036686897:  root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators ~_ter ^ ^ member ^ ^ ^ ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member', 'prefix_operators -> ~_ter']
before@4 batch0 x: -8.989996626973152: root modified ^ MemberReference-MemberReference member loc0 ^ ^ ^  prefix_operators ~_ter ^ ^ member ^ ^ ^  ; ['root -> modified', 'copy-MemberReference', 'MemberReference -> prefix_operators member', 'prefix_operators -> ~_ter']
stderr: Check out program version: Lang-61b........................................ OK
OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0
Running ant (export.dir.src.classes)....................................... OK

  0%|          | 0/1 [00:00<?, ?it/s]/root/projects/Recoder-bwk/run.py:527: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  tmpdepth = np.array(tmpdepth)
/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py:1340: UserWarning: nn.functional.tanh is deprecated. Use torch.tanh instead.
  warnings.warn("nn.functional.tanh is deprecated. Use torch.tanh instead.")
  0%|          | 0/1 [00:05<?, ?it/s]
Traceback (most recent call last):
  File "testDefect4j.py", line 638, in <module>
    ans = solveone(data, model)
  File "/root/projects/Recoder-bwk/run.py", line 1100, in solveone
    ans = BeamSearch((x[0], x[1], None, None, None, None, None, None, x[2], x[3]), dev_set, model, 100, args.batch_size, indexs)
  File "/root/projects/Recoder-bwk/run.py", line 541, in BeamSearch
    result = model(gVar(tmpnl), gVar(tmpnlad), gVar(tmprule), gVar(tmpruleparent), gVar(tmprulechild), gVar(tmpAd), gVar(tmptreepath), gVar(tmpnl8), gVar(tmpnl9), tmpf, tmpc, tmpindex, tmpchar, tmpindex2, rulead, antimasks, None, "test")
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 172, in forward
    genP1, _ = self.copy2(rulenoter.unsqueeze(0), decode)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 79, in forward
    genP = self.LinearRes(F.tanh(sourceLinear.unsqueeze(1) + targetLinear.unsqueeze(2))).squeeze(-1)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py", line 1341, in tanh
    return input.tanh()
RuntimeError: CUDA out of memory. Tried to allocate 1.53 GiB (GPU 0; 23.65 GiB total capacity; 2.28 GiB already allocated; 715.31 MiB free; 4.25 GiB cached)
