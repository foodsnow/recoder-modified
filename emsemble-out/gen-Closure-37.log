stdout: else_statement -> BlockStatement
using GPU
p
path com.google.javascript.jscomp.NodeTraversal
traverseFunction
Position(line=510, column=11)
FOUND IT!
path com.google.javascript.jscomp.parsing.IRFactory
processFunctionNode
Position(line=610, column=5)
FOUND IT!
[{'bugid': 'Closure-37', 'treeroot': <Searchnode.Node object at 0x7fc312fef310>, 'troot': <Searchnode.Node object at 0x7fc312fef310>, 'oldcode': '    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());', 'filepath': 'buggy/Closure-37/src/com/google/javascript/jscomp/NodeTraversal.java', 'subroot': <Searchnode.Node object at 0x7fc313005a10>, 'vardic': {'traverseFunction_ter': 'meth0', 'n_ter': 'par0', 'parent_ter': 'par1', 'fnName_ter': 'loc0', 'isFunctionExpression_ter': 'loc1', 'args_ter': 'loc2', 'body_ter': 'loc3'}, 'typedic': {'n_ter': 'Node', 'parent_ter': 'Node', 'fnName_ter': 'Node', 'isFunctionExpression_ter': 'boolean', 'args_ter': 'Node', 'body_ter': 'Node'}, 'idss': 'Closure-37', 'classname': 'com.google.javascript.jscomp.NodeTraversal', 'precode': '/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n\n/**\n * Nodetraversal allows an iteration through the nodes in the parse tree,\n * and facilitates the optimizations on the parse tree.\n *\n */\npublic class NodeTraversal {\n  // Package protected for tests\n  private final AbstractCompiler compiler;\n  private final Callback callback;\n\n  /** Contains the current node*/\n  private Node curNode;\n\n  public static final DiagnosticType NODE_TRAVERSAL_ERROR =\n      DiagnosticType.error("JSC_NODE_TRAVERSAL_ERROR", "{0}");\n\n  /**\n   * Stack containing the Scopes that have been created. The Scope objects\n   * are lazily created; so the {@code scopeRoots} stack contains the\n   * Nodes for all Scopes that have not been created yet.\n   */\n  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n\n  /**\n   * A stack of scope roots. All scopes that have not been created\n   * are represented in this Deque.\n   */\n  private final Deque<Node> scopeRoots = new ArrayDeque<Node>();\n\n\n  /**\n   * Stack of control flow graphs (CFG). There is one CFG per scope. CFGs\n   * are lazily populated: elements are {@code null} until requested by\n   * {@link #getControlFlowGraph()}. Note that {@link ArrayDeque} does not allow\n   * {@code null} elements, so {@link LinkedList} is used instead.\n   */\n  Deque<ControlFlowGraph<Node>> cfgs = new LinkedList<ControlFlowGraph<Node>>();\n\n  /** The current source file name */\n  private String sourceName;\n\n  /** The current input */\n  private InputId inputId;\n\n  /** The scope creator */\n  private ScopeCreator scopeCreator;\n\n  /** Possible callback for scope entry and exist **/\n  private ScopedCallback scopeCallback;\n\n  /**\n   * Callback\n   */\n  public interface Callback {\n    /**\n     * <p>Visits a node in pre order (before visiting its children) and decides\n     * whether this node\'s children should be traversed. If children are\n     * traversed, they will be visited by\n     * {@link #visit(NodeTraversal, Node, Node)} in post order.</p>\n     * <p>Implementations can have side effects (e.g. modifying the parse\n     * tree).</p>\n     * @return whether the children of this node should be visited\n     */\n    boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent);\n\n    /**\n     * <p>Visits a node in post order (after its children have been visited).\n     * A node is visited only if all its parents should be traversed\n     * ({@link #shouldTraverse(NodeTraversal, Node, Node)}).</p>\n     * <p>Implementations can have side effects (e.g. modifying the parse\n     * tree).</p>\n     */\n    void visit(NodeTraversal t, Node n, Node parent);\n  }\n\n  /**\n   * Callback that also knows about scope changes\n   */\n  public interface ScopedCallback extends Callback {\n\n    /**\n     * Called immediately after entering a new scope. The new scope can\n     * be accessed through t.getScope()\n     */\n    void enterScope(NodeTraversal t);\n\n    /**\n     * Called immediately before exiting a scope. The ending scope can\n     * be accessed through t.getScope()\n     */\n    void exitScope(NodeTraversal t);\n  }\n\n  /**\n   * Abstract callback to visit all nodes in post order.\n   */\n  public abstract static class AbstractPostOrderCallback implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n  }\n\n  /**\n   * Abstract scoped callback to visit all nodes in post order.\n   */\n  public abstract static class AbstractScopedCallback\n      implements ScopedCallback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {}\n\n    @Override\n    public void exitScope(NodeTraversal t) {}\n  }\n\n  /**\n   * Abstract callback to visit all nodes but not traverse into function\n   * bodies.\n   */\n  public abstract static class AbstractShallowCallback implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      // We do want to traverse the name of a named function, but we don\'t\n      // want to traverse the arguments or body.\n      return parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild();\n    }\n  }\n\n  /**\n   * Abstract callback to visit all structure and statement nodes but doesn\'t\n   * traverse into functions or expressions.\n   */\n  public abstract static class AbstractShallowStatementCallback\n      implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }\n  }\n\n  /**\n   * Abstract callback to visit a pruned set of nodes.\n   */\n  public abstract static class AbstractNodeTypePruningCallback\n        implements Callback {\n    private final Set<Integer> nodeTypes;\n    private final boolean include;\n\n    /**\n     * Creates an abstract pruned callback.\n     * @param nodeTypes the nodes to include in the traversal\n     */\n    public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes) {\n      this(nodeTypes, true);\n    }\n\n    /**\n     * Creates an abstract pruned callback.\n     * @param nodeTypes the nodes to include/exclude in the traversal\n     * @param include whether to include or exclude the nodes in the traversal\n     */\n    public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes,\n          boolean include) {\n      this.nodeTypes = nodeTypes;\n      this.include = include;\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return include == nodeTypes.contains(n.getType());\n    }\n  }\n\n  /**\n   * Creates a node traversal using the specified callback interface.\n   */\n  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }\n\n  /**\n   * Creates a node traversal using the specified callback interface\n   * and the scope creator.\n   */\n  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = "";\n    this.scopeCreator = scopeCreator;\n  }\n\n  private void throwUnexpectedException(Exception unexpectedException) {\n    // If there\'s an unexpected exception, try to get the\n    // line number of the code that caused it.\n    String message = unexpectedException.getMessage();\n\n    // TODO(user): It is possible to get more information if curNode or\n    // its parent is missing. We still have the scope stack in which it is still\n    // very useful to find out at least which function caused the exception.\n    if (inputId != null) {\n      message =\n          unexpectedException.getMessage() + "\\n" +\n          formatNodeContext("Node", curNode) +\n          (curNode == null ?\n              "" :\n              formatNodeContext("Parent", curNode.getParent()));\n    }\n    compiler.throwInternalError(message, unexpectedException);\n  }\n\n  private String formatNodeContext(String label, Node n) {\n    if (n == null) {\n      return "  " + label + ": NULL";\n    }\n    return "  " + label + "(" + n.toString(false, false, false) + "): "\n        + formatNodePosition(n);\n  }\n\n  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = "";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n\n  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }\n\n  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = "";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n\n  private static final String MISSING_SOURCE = "[source unknown]";\n\n  private String formatNodePosition(Node n) {\n    if (n == null) {\n      return MISSING_SOURCE + "\\n";\n    }\n\n    int lineNumber = n.getLineno();\n    int columnNumber = n.getCharno();\n    String src = compiler.getSourceLine(sourceName, lineNumber);\n    if (src == null) {\n      src = MISSING_SOURCE;\n    }\n    return sourceName + ":" + lineNumber + ":" + columnNumber + "\\n"\n        + src + "\\n";\n  }\n\n  /**\n   * Traverses a parse tree recursively with a scope, starting with the given\n   * root. This should only be used in the global scope. Otherwise, use\n   * {@link #traverseAtScope}.\n   */\n  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    inputId = null;\n    sourceName = "";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }\n\n  /**\n   * Traverses a parse tree recursively with a scope, starting at that scope\'s\n   * root.\n   */\n  void traverseAtScope(Scope s) {\n    Node n = s.getRootNode();\n    if (n.isFunction()) {\n      // We need to do some extra magic to make sure that the scope doesn\'t\n      // get re-created when we dive into the function.\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n      }\n      sourceName = getSourceName(n);\n      curNode = n;\n      pushScope(s);\n\n      Node args = n.getFirstChild().getNext();\n      Node body = args.getNext();\n      traverseBranch(args, n);\n      traverseBranch(body, n);\n\n      popScope();\n    } else {\n      traverseWithScope(n, s);\n    }\n  }\n\n  /**\n   * Traverses an inner node recursively with a refined scope. An inner node may\n   * be any node with a non {@code null} parent (i.e. all nodes except the\n   * root).\n   *\n   * @param node the node to traverse\n   * @param parent the node\'s parent, it may be not be {@code null}\n   * @param refinedScope the refined scope of the scope currently at the top of\n   *     the scope stack or in trivial cases that very scope or {@code null}\n   */\n  protected void traverseInnerNode(Node node, Node parent, Scope refinedScope) {\n    Preconditions.checkNotNull(parent);\n    if (refinedScope != null && getScope() != refinedScope) {\n      curNode = node;\n      pushScope(refinedScope);\n      traverseBranch(node, parent);\n      popScope();\n    } else {\n      traverseBranch(node, parent);\n    }\n  }\n\n  /**\n   * Gets the compiler.\n   */\n  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }\n\n  /**\n   * Gets the current line number, or zero if it cannot be determined. The line\n   * number is retrieved lazily as a running time optimization.\n   */\n  public int getLineNumber() {\n    Node cur = curNode;\n    while (cur != null) {\n      int line = cur.getLineno();\n      if (line >=0) {\n        return line;\n      }\n      cur = cur.getParent();\n    }\n    return 0;\n  }\n\n  /**\n   * Gets the current input source name.\n   *\n   * @return A string that may be empty, but not null\n   */\n  public String getSourceName() {\n    return sourceName;\n  }\n\n  /**\n   * Gets the current input source.\n   */\n  public CompilerInput getInput() {\n    return compiler.getInput(inputId);\n  }\n\n  /**\n   * Gets the current input module.\n   */\n  public JSModule getModule() {\n    CompilerInput input = getInput();\n    return input == null ? null : input.getModule();\n  }\n\n  /** Returns the node currently being traversed. */\n  public Node getCurrentNode() {\n    return curNode;\n  }\n\n  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }\n\n  /**\n   * Traverses a list of node trees.\n   */\n  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n\n  public static void traverseRoots(\n      AbstractCompiler compiler, Callback cb, Node ... roots) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n\n  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings("fallthrough")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }\n\n  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body', 'aftercode': '    traverseBranch(body, n);\n\n    popScope();\n  }\n\n  /** Examines the functions stack for the last instance of a function node. */\n  @SuppressWarnings("unchecked")\n  public Node getEnclosingFunction() {\n    if (scopes.size() + scopeRoots.size() < 2) {\n      return null;\n    } else {\n      if (scopeRoots.isEmpty()) {\n        return scopes.peek().getRootNode();\n      } else {\n        return scopeRoots.peek();\n      }\n    }\n  }\n\n  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n\n  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n\n  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }\n\n  /** Gets the current scope. */\n  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }\n\n  /** Gets the control flow graph for the current JS scope. */\n  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }\n\n  /** Returns the current scope\'s root. */\n  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }\n\n  /**\n   * Determines whether the traversal is currently in the global scope.\n   */\n  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }\n\n  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }\n\n  public boolean hasScope() {\n    return !(scopes.isEmpty() && scopeRoots.isEmpty());\n  }\n\n  /** Reports a diagnostic (error or warning) */\n  public void report(Node n, DiagnosticType diagnosticType,\n      String... arguments) {\n    JSError error = JSError.make(getSourceName(), n, diagnosticType, arguments);\n    compiler.report(error);\n  }\n\n  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? "" : name;\n  }\n\n  InputId getInputId() {\n    return inputId;\n  }\n\n  /**\n   * Creates a JSError during NodeTraversal.\n   *\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   */\n  public JSError makeError(Node n, CheckLevel level, DiagnosticType type,\n      String... arguments) {\n    return JSError.make(getSourceName(), n, level, type, arguments);\n  }\n\n  /**\n   * Creates a JSError during NodeTraversal.\n   *\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   */\n  public JSError makeError(Node n, DiagnosticType type, String... arguments) {\n    return JSError.make(getSourceName(), n, type, arguments);\n  }\n}', 'tree': 'MethodDeclaration modifiers private_ter ^ ^ name meth0 ^ ^ parameters FormalParameter type ReferenceType name Node_ter ^ ^ ^ ^ name par0 ^ ^ ^ FormalParameter type ReferenceType name Node_ter ^ ^ ^ ^ name par1 ^ ^ ^ ^ body StatementExpression expression MethodInvocation qualifier Preconditions_ter ^ ^ arguments BinaryOperation operator ==_ter ^ ^ operandl MethodInvocation qualifier par0 ^ ^ member getChildCount_ter ^ ^ ^ ^ operandr Literal value 3_ter ^ ^ ^ ^ ^ ^ member checkState_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier Preconditions_ter ^ ^ arguments MethodInvocation qualifier par0 ^ ^ member isFunction_ter ^ ^ ^ ^ member checkState_ter ^ ^ ^ ^ ^ LocalVariableDeclaration modifiers final_ter ^ ^ type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier par0 ^ ^ member getFirstChild_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name boolean_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator !=_ter ^ ^ operandl MemberReference member par1 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr MethodInvocation qualifier NodeUtil_ter ^ ^ arguments MemberReference member par0 ^ ^ ^ ^ member loc1 ^ ^ ^ ^ ^ ^ ^ ^ ^ IfStatement condition MemberReference prefix_operators !_ter ^ ^ member loc1 ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression MethodInvocation arguments MemberReference member loc0 ^ ^ ^ MemberReference member par0 ^ ^ ^ ^ member traverseBranch_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member curNode_ter ^ ^ ^ ^ value MemberReference member par0 ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation arguments MemberReference member par0 ^ ^ ^ ^ member pushScope_ter ^ ^ ^ ^ ^ IfStatement condition MemberReference member loc1 ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression MethodInvocation arguments MemberReference member loc0 ^ ^ ^ MemberReference member par0 ^ ^ ^ ^ member traverseBranch_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration modifiers final_ter ^ ^ type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer MethodInvocation qualifier loc0 ^ ^ member getNext_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration modifiers final_ter ^ ^ type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation qualifier loc2 ^ ^ member getNext_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation arguments MemberReference member loc2 ^ ^ ^ MemberReference member par0 ^ ^ ^ ^ member traverseBranch_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier Preconditions_ter ^ ^ arguments BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator ==_ter ^ ^ operandl MethodInvocation qualifier loc3 ^ ^ member getNext_ter ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ operandr MethodInvocation qualifier loc3 ^ ^ member isBlock_ter ^ ^ ^ ^ ^ ^ member checkState_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation arguments MemberReference member loc3 ^ ^ ^ MemberReference member par0 ^ ^ ^ ^ member traverseBranch_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation member popScope_ter ^ ^ ^ ^ ^ ^ ^ ', 'prob': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2], 'mode': 0, 'line': 540, 'isa': False, 'fl_score': 1}, {'bugid': 'Closure-37', 'treeroot': <Searchnode.Node object at 0x7fc30de8a110>, 'troot': <Searchnode.Node object at 0x7fc316f2b510>, 'oldcode': '      Node bodyNode = transform(functionNode.getBody());', 'filepath': 'buggy/Closure-37/src/com/google/javascript/jscomp/parsing/IRFactory.java', 'subroot': <Searchnode.Node object at 0x7fc30de3b890>, 'vardic': {'processFunctionNode_ter': 'meth0', 'name_ter': 'loc0', 'isUnnamedFunction_ter': 'loc1', 'functionType_ter': 'loc2', 'node_ter': 'loc3', 'newName_ter': 'loc4', 'lpColumn_ter': 'loc5', 'lp_ter': 'loc6', 'fnName_ter': 'loc7', 'lparenCharno_ter': 'loc8', 'param_ter': 'loc9', 'bodyNode_ter': 'loc10'}, 'typedic': {'name_ter': 'Name', 'isUnnamedFunction_ter': 'Boolean', 'functionType_ter': 'int', 'node_ter': 'Node', 'newName_ter': 'Node', 'lpColumn_ter': 'int', 'lp_ter': 'Node', 'fnName_ter': 'Name', 'lparenCharno_ter': 'int', 'param_ter': 'AstNode', 'bodyNode_ter': 'Node'}, 'idss': 'Closure-37', 'classname': 'com.google.javascript.jscomp.parsing.IRFactory', 'precode': '/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp.parsing;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.parsing.Config.LanguageMode;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.head.Token.CommentType;\nimport com.google.javascript.rhino.head.ast.ArrayLiteral;\nimport com.google.javascript.rhino.head.ast.Assignment;\nimport com.google.javascript.rhino.head.ast.AstNode;\nimport com.google.javascript.rhino.head.ast.AstRoot;\nimport com.google.javascript.rhino.head.ast.Block;\nimport com.google.javascript.rhino.head.ast.BreakStatement;\nimport com.google.javascript.rhino.head.ast.CatchClause;\nimport com.google.javascript.rhino.head.ast.Comment;\nimport com.google.javascript.rhino.head.ast.ConditionalExpression;\nimport com.google.javascript.rhino.head.ast.ContinueStatement;\nimport com.google.javascript.rhino.head.ast.DoLoop;\nimport com.google.javascript.rhino.head.ast.ElementGet;\nimport com.google.javascript.rhino.head.ast.EmptyExpression;\nimport com.google.javascript.rhino.head.ast.ExpressionStatement;\nimport com.google.javascript.rhino.head.ast.ForInLoop;\nimport com.google.javascript.rhino.head.ast.ForLoop;\nimport com.google.javascript.rhino.head.ast.FunctionCall;\nimport com.google.javascript.rhino.head.ast.FunctionNode;\nimport com.google.javascript.rhino.head.ast.IfStatement;\nimport com.google.javascript.rhino.head.ast.InfixExpression;\nimport com.google.javascript.rhino.head.ast.KeywordLiteral;\nimport com.google.javascript.rhino.head.ast.Label;\nimport com.google.javascript.rhino.head.ast.LabeledStatement;\nimport com.google.javascript.rhino.head.ast.Name;\nimport com.google.javascript.rhino.head.ast.NewExpression;\nimport com.google.javascript.rhino.head.ast.NumberLiteral;\nimport com.google.javascript.rhino.head.ast.ObjectLiteral;\nimport com.google.javascript.rhino.head.ast.ObjectProperty;\nimport com.google.javascript.rhino.head.ast.ParenthesizedExpression;\nimport com.google.javascript.rhino.head.ast.PropertyGet;\nimport com.google.javascript.rhino.head.ast.RegExpLiteral;\nimport com.google.javascript.rhino.head.ast.ReturnStatement;\nimport com.google.javascript.rhino.head.ast.Scope;\nimport com.google.javascript.rhino.head.ast.StringLiteral;\nimport com.google.javascript.rhino.head.ast.SwitchCase;\nimport com.google.javascript.rhino.head.ast.SwitchStatement;\nimport com.google.javascript.rhino.head.ast.ThrowStatement;\nimport com.google.javascript.rhino.head.ast.TryStatement;\nimport com.google.javascript.rhino.head.ast.UnaryExpression;\nimport com.google.javascript.rhino.head.ast.VariableDeclaration;\nimport com.google.javascript.rhino.head.ast.VariableInitializer;\nimport com.google.javascript.rhino.head.ast.WhileLoop;\nimport com.google.javascript.rhino.head.ast.WithStatement;\nimport com.google.javascript.rhino.jstype.StaticSourceFile;\n\nimport java.util.Set;\n\n/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n\n  static final String SUSPICIOUS_COMMENT_WARNING =\n      "Non-JSDoc comment has annotations. " +\n      "Did you mean to start it with \'/**\'?";\n\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n\n  // non-static for thread safety\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet("use strict");\n\n  private static final Set<String> ES5_RESERVED_KEYWORDS =\n      ImmutableSet.of(\n          // From Section 7.6.1.2\n          "class", "const", "enum", "export", "extends", "import", "super");\n  private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS =\n      ImmutableSet.of(\n          // From Section 7.6.1.2\n          "class", "const", "enum", "export", "extends", "import", "super",\n          "implements", "interface", "let", "package", "private", "protected",\n          "public", "static", "yield");\n\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n\n  // @license text gets appended onto the fileLevelJsDocBuilder as found,\n  // and stored in JSDocInfo for placeholder node.\n  Node rootNodeJsDocHolder = new Node(Token.SCRIPT);\n  Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n      rootNodeJsDocHolder.getJsDocBuilderForNode();\n  JSDocInfo fileOverviewInfo = null;\n\n  // Use a template node for properties set on all nodes to minimize the\n  // memory footprint associated with these.\n  private Node templateNode;\n\n  // TODO(johnlenz): Consider creating a template pool for ORIGINALNAME_PROP.\n\n  private IRFactory(String sourceString,\n                    StaticSourceFile sourceFile,\n                    Config config,\n                    ErrorReporter errorReporter) {\n    this.sourceString = sourceString;\n    this.sourceFile = sourceFile;\n\n    // Sometimes this will be null in tests.\n    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n\n    this.config = config;\n    this.errorReporter = errorReporter;\n    this.transformDispatcher = new TransformDispatcher();\n    // The template node properties are applied to all nodes in this transform.\n    this.templateNode = createTemplateNode();\n\n    switch (config.languageMode) {\n      case ECMASCRIPT3:\n        // Reserved words are handled by the Rhino parser.\n        reservedKeywords = null;\n        break;\n      case ECMASCRIPT5:\n        reservedKeywords = ES5_RESERVED_KEYWORDS;\n        break;\n      case ECMASCRIPT5_STRICT:\n        reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS;\n        break;\n      default:\n        throw new IllegalStateException("unknown language mode");\n    }\n  }\n\n  // Create a template node to use as a source of common attributes, this allows\n  // the prop structure to be shared among all the node from this source file.\n  // This reduces the cost of these properties to O(nodes) to O(files).\n  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }\n\n  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }\n\n  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we\'ve seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo();\n    if (rootNodeJsDoc != null) {\n      irNode.setJSDocInfo(rootNodeJsDoc);\n      rootNodeJsDoc.setAssociatedNode(irNode);\n    }\n\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n      fileOverviewInfo.setAssociatedNode(irNode);\n    }\n  }\n\n  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (!irNode.isBlock()) {\n      if (irNode.isEmpty()) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        maybeSetLengthFrom(newBlock, node);\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }\n\n  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    String value = comment.getValue();\n    if (value.indexOf("/* @") != -1 ||\n        value.indexOf("\\n * @") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), "", 0);\n    }\n  }\n\n  /**\n   * @return true if the jsDocParser represents a fileoverview.\n   */\n  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n\n  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n    parsedComments.add(comment);\n    handlePossibleFileOverviewJsDoc(jsDocParser);\n  }\n\n  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }\n\n  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n\n  private Node transformNameAsString(Name node) {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n\n  private Node transformNumberAsString(NumberLiteral literalNode) {\n    Node irNode = newStringNode(getStringValue(literalNode.getNumber()));\n    JSDocInfo jsDocInfo = handleJsDoc(literalNode, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, literalNode);\n    return irNode;\n  }\n\n  private static String getStringValue(double value) {\n    long longValue = (long) value;\n\n    // Return "1" instead of "1.0"\n    if (longValue == value) {\n      return Long.toString(longValue);\n    } else {\n      return Double.toString(value);\n    }\n  }\n\n  private void setSourceInfo(Node irNode, AstNode node) {\n    if (irNode.getLineno() == -1) {\n      // If we didn\'t already set the line, then set it now. This avoids\n      // cases like ParenthesizedExpression where we just return a previous\n      // node, but don\'t want the new node to get its parent\'s line number.\n      int lineno = node.getLineno();\n      irNode.setLineno(lineno);\n      int charno = position2charno(node.getAbsolutePosition());\n      irNode.setCharno(charno);\n      maybeSetLengthFrom(irNode, node);\n    }\n  }\n\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n   *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial \'/**\'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n\n  // Set the length on the node if we\'re in IDE mode.\n  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }\n\n  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf(\'\\n\', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }\n\n  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }\n\n  private class TransformDispatcher extends TypeSafeDispatcher<Node> {\n    private Node processGeneric(\n        com.google.javascript.rhino.head.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.rhino.head.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }\n\n    /**\n     * Transforms the given node and then sets its type to Token.STRING if it\n     * was Token.NAME. If its type was already Token.STRING, then quotes it.\n     * Used for properties, as the old AST uses String tokens, while the new one\n     * uses Name tokens for unquoted strings. For example, in\n     * var o = {\'a\' : 1, b: 2};\n     * the string \'a\' is quoted, while the name b is turned into a string, but\n     * unquoted.\n     */\n    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name)n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral)n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.isString());\n      return ret;\n    }\n\n    @Override\n    Node processArrayLiteral(ArrayLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.ARRAYLIT);\n      for (AstNode child : literalNode.getElements()) {\n        Node c = transform(child);\n        node.addChildToBack(c);\n      }\n      return node;\n    }\n\n    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          "invalid assignment target",\n          sourceName,\n          target.getLineno(), "", 0);\n      }\n      return assign;\n    }\n\n    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.rhino.head.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }\n\n    /**\n     * Parse the directives, encode them in the AST, and remove their nodes.\n     *\n     * For information on ES5 directives, see section 14.1 of\n     * Ecma-262, Edition 5.\n     *\n     * It would be nice if Rhino would eventually take care of this for\n     * us, but right now their directive-processing is a one-off.\n     */\n    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }\n\n    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            "Catch clauses are not supported",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), "", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            "unsupported language extension: for each",\n            sourceName,\n            loopNode.getLineno(), "", 0);\n\n        // Return the bare minimum to put the AST in a valid state.\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(\n          Token.FOR,\n          transform(loopNode.getInitializer()),\n          transform(loopNode.getCondition()),\n          transform(loopNode.getIncrement()));\n      node.addChildToBack(transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      node.setLineno(node.getFirstChild().getLineno());\n      node.setCharno(node.getFirstChild().getCharno());\n      maybeSetLengthFrom(node, callNode);\n      return node;\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            "unnamed function statement",\n            sourceName,\n            functionNode.getLineno(), "", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier("");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren\'s complicated because it\'s not represented by an\n      // AstNode, so there\'s nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there\'s no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n', 'aftercode': '        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn\'t support, repair it here. see Rhino\'s\n        // Parser#parseFunctionBodyExpr.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF);\n      node.addChildToBack(transform(statementNode.getCondition()));\n      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n      }\n      return node;\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      n.setLineno(exprNode.getLineno());\n      n.setCharno(position2charno(exprNode.getAbsolutePosition()));\n      maybeSetLengthFrom(n, exprNode);\n      return n;\n    }\n\n    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }\n\n    @Override\n    Node processLabel(Label labelNode) {\n      return newStringNode(Token.LABEL_NAME, labelNode.getName());\n    }\n\n    @Override\n    Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL);\n      Node prev = null;\n      Node cur = node;\n      for (Label label : statementNode.getLabels()) {\n        if (prev != null) {\n          prev.addChildToBack(cur);\n        }\n        cur.addChildToBack(transform(label));\n\n        cur.setLineno(label.getLineno());\n        maybeSetLengthFrom(cur, label);\n\n        int clauseAbsolutePosition =\n            position2charno(label.getAbsolutePosition());\n        cur.setCharno(clauseAbsolutePosition);\n\n        prev = cur;\n        cur = newNode(Token.LABEL);\n      }\n      prev.addChildToBack(transform(statementNode.getStatement()));\n      return node;\n    }\n\n    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }\n\n    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            "identifier is a reserved word",\n            sourceName,\n            nameNode.getLineno(), "", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }\n\n    /**\n     * @return Whether the\n     */\n    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }\n\n    @Override\n    Node processNewExpression(NewExpression exprNode) {\n      return processFunctionCall(exprNode);\n    }\n\n    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.OBJECTLIT);\n      for (ObjectProperty el : literalNode.getElements()) {\n        if (config.languageMode == LanguageMode.ECMASCRIPT3) {\n          if (el.isGetter()) {\n            reportGetter(el);\n            continue;\n          } else if (el.isSetter()) {\n            reportSetter(el);\n            continue;\n          }\n        }\n\n        Node key = transformAsString(el.getLeft());\n        Node value = transform(el.getRight());\n        if (el.isGetter()) {\n          key.setType(Token.GETTER_DEF);\n          Preconditions.checkState(value.isFunction());\n          if (getFnParamNode(value).hasChildren()) {\n            reportGetterParam(el.getLeft());\n          }\n        } else if (el.isSetter()) {\n          key.setType(Token.SETTER_DEF);\n          Preconditions.checkState(value.isFunction());\n          if (!getFnParamNode(value).hasOneChild()) {\n            reportSetterParam(el.getLeft());\n          }\n        }\n        key.addChildToFront(value);\n        node.addChildToBack(key);\n      }\n      return node;\n    }\n\n    /**\n     * @param fnNode The function.\n     * @return The Node containing the Function parameters.\n     */\n   Node getFnParamNode(Node fnNode) {\n     // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n     Preconditions.checkArgument(fnNode.isFunction());\n     return fnNode.getFirstChild().getNext();\n   }\n\n    @Override\n    Node processObjectProperty(ObjectProperty propertyNode) {\n      return processInfixExpression(propertyNode);\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n      Node node = transform(exprNode.getExpression());\n      node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n      return node;\n    }\n\n    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      Node leftChild = transform(getNode.getTarget());\n      Node newNode = newNode(\n          Token.GETPROP, leftChild, transformAsString(getNode.getProperty()));\n      newNode.setLineno(leftChild.getLineno());\n      newNode.setCharno(leftChild.getCharno());\n      maybeSetLengthFrom(newNode, getNode);\n      return newNode;\n    }\n\n    @Override\n    Node processRegExpLiteral(RegExpLiteral literalNode) {\n      Node literalStringNode = newStringNode(literalNode.getValue());\n      // assume it\'s on the same line.\n      literalStringNode.setLineno(literalNode.getLineno());\n      maybeSetLengthFrom(literalStringNode, literalNode);\n      Node node = newNode(Token.REGEXP, literalStringNode);\n      String flags = literalNode.getFlags();\n      if (flags != null && !flags.isEmpty()) {\n        Node flagsNode = newStringNode(flags);\n        // Assume the flags are on the same line as the literal node.\n        flagsNode.setLineno(literalNode.getLineno());\n        maybeSetLengthFrom(flagsNode, literalNode);\n        node.addChildToBack(flagsNode);\n      }\n      return node;\n    }\n\n    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n\n    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }\n\n    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n      String value = literalNode.getValue();\n      Node n = newStringNode(value);\n      if (value.indexOf(\'\\u000B\') != -1) {\n        // NOTE(nicksantos): In JavaScript, there are 3 ways to\n        // represent a vertical tab: \\v, \\x0B, \\u000B.\n        // The \\v notation was added later, and is not understood\n        // on IE. So we need to preserve it as-is. This is really\n        // obnoxious, because we do not have a good way to represent\n        // how the original string was encoded without making the\n        // representation of strings much more complicated.\n        //\n        // To handle this, we look at the original source test, and\n        // mark the string as \\v-encoded or not. If a string is\n        // \\v encoded, then all the vertical tabs in that string\n        // will be encoded with a \\v.\n        int start = literalNode.getAbsolutePosition();\n        int end = start + literalNode.getLength();\n        if (start < sourceString.length() &&\n            (sourceString.substring(\n                 start, Math.min(sourceString.length(), end))\n             .indexOf("\\\\v") != -1)) {\n          n.putBooleanProp(Node.SLASH_V, true);\n        }\n      }\n      return n;\n    }\n\n    @Override\n    Node processSwitchCase(SwitchCase caseNode) {\n      Node node;\n      if (caseNode.isDefault()) {\n        node = newNode(Token.DEFAULT_CASE);\n      } else {\n        AstNode expr = caseNode.getExpression();\n        node = newNode(Token.CASE, transform(expr));\n      }\n      Node block = newNode(Token.BLOCK);\n      block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n      block.setLineno(caseNode.getLineno());\n      block.setCharno(position2charno(caseNode.getAbsolutePosition()));\n      maybeSetLengthFrom(block, caseNode);\n      if (caseNode.getStatements() != null) {\n        for (AstNode child : caseNode.getStatements()) {\n          block.addChildToBack(transform(child));\n        }\n      }\n      node.addChildToBack(block);\n      return node;\n    }\n\n    @Override\n    Node processSwitchStatement(SwitchStatement statementNode) {\n      Node node = newNode(Token.SWITCH,\n          transform(statementNode.getExpression()));\n      for (AstNode child : statementNode.getCases()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n\n    @Override\n    Node processThrowStatement(ThrowStatement statementNode) {\n      return newNode(Token.THROW,\n          transform(statementNode.getExpression()));\n    }\n\n    @Override\n    Node processTryStatement(TryStatement statementNode) {\n      Node node = newNode(Token.TRY,\n          transformBlock(statementNode.getTryBlock()));\n      Node block = newNode(Token.BLOCK);\n      boolean lineSet = false;\n\n      for (CatchClause cc : statementNode.getCatchClauses()) {\n        // Mark the enclosing block at the same line as the first catch\n        // clause.\n        if (lineSet == false) {\n          block.setLineno(cc.getLineno());\n          maybeSetLengthFrom(block, cc);\n          lineSet = true;\n        }\n        block.addChildToBack(transform(cc));\n      }\n      node.addChildToBack(block);\n\n      AstNode finallyBlock = statementNode.getFinallyBlock();\n      if (finallyBlock != null) {\n        node.addChildToBack(transformBlock(finallyBlock));\n      }\n\n      // If we didn\'t set the line on the catch clause, then\n      // we\'ve got an empty catch clause.  Set its line to be the same\n      // as the finally block (to match Old Rhino\'s behavior.)\n      if ((lineSet == false) && (finallyBlock != null)) {\n        block.setLineno(finallyBlock.getLineno());\n        maybeSetLengthFrom(block, finallyBlock);\n      }\n\n      return node;\n    }\n\n    @Override\n    Node processUnaryExpression(UnaryExpression exprNode) {\n      int type = transformTokenType(exprNode.getType());\n      Node operand = transform(exprNode.getOperand());\n      if (type == Token.NEG && operand.isNumber()) {\n        operand.setDouble(-operand.getDouble());\n        return operand;\n      } else {\n        if (type == Token.DELPROP &&\n            !(operand.isGetProp() ||\n              operand.isGetElem() ||\n              operand.isName())) {\n          String msg =\n              "Invalid delete operand. Only properties can be deleted.";\n          errorReporter.error(\n              msg,\n              sourceName,\n              operand.getLineno(), "", 0);\n        } else  if (type == Token.INC || type == Token.DEC) {\n          if (!validAssignmentTarget(operand)) {\n            String msg = (type == Token.INC)\n                ? "invalid increment target"\n                : "invalid decrement target";\n            errorReporter.error(\n                msg,\n                sourceName,\n                operand.getLineno(), "", 0);\n          }\n        }\n\n        Node node = newNode(type, operand);\n        if (exprNode.isPostfix()) {\n          node.putBooleanProp(Node.INCRDECR_PROP, true);\n        }\n        return node;\n      }\n    }\n\n    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n\n    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.rhino.head.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n\n    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        Node initalizer = transform(initializerNode.getInitializer());\n        node.addChildToBack(initalizer);\n      }\n      return node;\n    }\n\n    @Override\n    Node processWhileLoop(WhileLoop loopNode) {\n      return newNode(\n          Token.WHILE,\n          transform(loopNode.getCondition()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processWithStatement(WithStatement statementNode) {\n      return newNode(\n          Token.WITH,\n          transform(statementNode.getExpression()),\n          transformBlock(statementNode.getStatement()));\n    }\n\n    @Override\n    Node processIllegalToken(AstNode node) {\n      errorReporter.error(\n          "Unsupported syntax: " +\n          com.google.javascript.rhino.head.Token.typeToName(\n              node.getType()),\n          sourceName,\n          node.getLineno(), "", 0);\n      return newNode(Token.EMPTY);\n    }\n\n    void reportDestructuringAssign(AstNode node) {\n      errorReporter.error(\n          "destructuring assignment forbidden",\n          sourceName,\n          node.getLineno(), "", 0);\n    }\n\n    void reportGetter(AstNode node) {\n      errorReporter.error(\n          "getters are not supported in Internet Explorer",\n          sourceName,\n          node.getLineno(), "", 0);\n    }\n\n    void reportSetter(AstNode node) {\n      errorReporter.error(\n          "setters are not supported in Internet Explorer",\n          sourceName,\n          node.getLineno(), "", 0);\n    }\n\n    void reportGetterParam(AstNode node) {\n      errorReporter.error(\n          "getters may not have parameters",\n          sourceName,\n          node.getLineno(), "", 0);\n    }\n\n    void reportSetterParam(AstNode node) {\n      errorReporter.error(\n          "setters must have exactly one parameter",\n          sourceName,\n          node.getLineno(), "", 0);\n    }\n  }\n\n  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.rhino.head.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.rhino.head.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.rhino.head.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.rhino.head.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.rhino.head.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.rhino.head.Token.NE:\n        return Token.NE;\n      case com.google.javascript.rhino.head.Token.LT:\n        return Token.LT;\n      case com.google.javascript.rhino.head.Token.LE:\n        return Token.LE;\n      case com.google.javascript.rhino.head.Token.GT:\n        return Token.GT;\n      case com.google.javascript.rhino.head.Token.GE:\n        return Token.GE;\n      case com.google.javascript.rhino.head.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.rhino.head.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.rhino.head.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.rhino.head.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.rhino.head.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.rhino.head.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.rhino.head.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.rhino.head.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.rhino.head.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.rhino.head.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.rhino.head.Token.POS:\n        return Token.POS;\n      case com.google.javascript.rhino.head.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.rhino.head.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.rhino.head.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.rhino.head.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.rhino.head.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.rhino.head.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.rhino.head.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.rhino.head.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.rhino.head.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.rhino.head.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.rhino.head.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.rhino.head.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.rhino.head.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.rhino.head.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.rhino.head.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.rhino.head.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.rhino.head.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.rhino.head.Token.IN:\n        return Token.IN;\n      case com.google.javascript.rhino.head.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.rhino.head.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.rhino.head.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.rhino.head.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.rhino.head.Token.LP:\n        return Token.PARAM_LIST;\n      case com.google.javascript.rhino.head.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.rhino.head.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.rhino.head.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.rhino.head.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.rhino.head.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.rhino.head.Token.OR:\n        return Token.OR;\n      case com.google.javascript.rhino.head.Token.AND:\n        return Token.AND;\n      case com.google.javascript.rhino.head.Token.INC:\n        return Token.INC;\n      case com.google.javascript.rhino.head.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.rhino.head.Token.IF:\n        return Token.IF;\n      case com.google.javascript.rhino.head.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.rhino.head.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.rhino.head.Token.DEFAULT:\n        return Token.DEFAULT_CASE;\n      case com.google.javascript.rhino.head.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.rhino.head.Token.DO:\n        return Token.DO;\n      case com.google.javascript.rhino.head.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.rhino.head.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.rhino.head.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.rhino.head.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.rhino.head.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.rhino.head.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.rhino.head.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.rhino.head.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.rhino.head.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.rhino.head.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.rhino.head.Token.EXPR_VOID:\n      case com.google.javascript.rhino.head.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.rhino.head.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.rhino.head.Token.GET:\n        return Token.GETTER_DEF;\n      case com.google.javascript.rhino.head.Token.SET:\n        return Token.SETTER_DEF;\n      case com.google.javascript.rhino.head.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.rhino.head.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }\n\n  // Simple helper to create nodes and set the initial node properties.\n  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1, Node child2, Node child3) {\n    return new Node(type, child1, child2, child3).clonePropsFrom(templateNode);\n  }\n\n  private Node newStringNode(String value) {\n    return IR.string(value).clonePropsFrom(templateNode);\n  }\n\n  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }\n\n  private Node newNumberNode(Double value) {\n    return IR.number(value).clonePropsFrom(templateNode);\n  }\n}', 'tree': 'MethodDeclaration body LocalVariableDeclaration type ReferenceType name Name_ter ^ ^ ^ ^ declarators VariableDeclarator name loc0 ^ ^ initializer MethodInvocation qualifier functionNode_ter ^ ^ member getFunctionName_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Boolean_ter ^ ^ ^ ^ declarators VariableDeclarator name loc1 ^ ^ initializer Literal value false_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator ==_ter ^ ^ operandl MemberReference member loc0 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc2 ^ ^ initializer MethodInvocation qualifier functionNode_ter ^ ^ member getFunctionType_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member loc2 ^ ^ ^ ^ operandr MemberReference qualifier FunctionNode_ter ^ ^ member FUNCTION_EXPRESSION_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression MethodInvocation qualifier errorReporter_ter ^ ^ arguments Literal value <string>_ter ^ ^ ^ MemberReference member sourceName_ter ^ ^ ^ MethodInvocation qualifier functionNode_ter ^ ^ member getLineno_ter ^ ^ ^ Literal value <string>_ter ^ ^ ^ Literal value 0_ter ^ ^ ^ ^ member error_ter ^ ^ ^ ^ ^ ReturnStatement expression MethodInvocation arguments MemberReference qualifier Token_ter ^ ^ member EXPR_RESULT_ter ^ ^ ^ MethodInvocation qualifier Node_ter ^ ^ arguments Literal value 0_ter ^ ^ ^ ^ member newNumber_ter ^ ^ ^ ^ member newNode_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc0 ^ ^ ^ ^ value ClassCreator type ReferenceType name Name_ter ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc0 ^ ^ arguments Literal value <string>_ter ^ ^ ^ ^ member setIdentifier_ter ^ ^ ^ ^ ^ StatementExpression expression Assignment expressionl MemberReference member loc1 ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc3 ^ ^ initializer MethodInvocation arguments MemberReference qualifier Token_ter ^ ^ member FUNCTION_ter ^ ^ ^ ^ member newNode_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc4 ^ ^ initializer MethodInvocation arguments MemberReference member loc0 ^ ^ ^ ^ member transform_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition MemberReference member loc1 ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression MethodInvocation qualifier loc4 ^ ^ arguments MethodInvocation qualifier functionNode_ter ^ ^ member getLineno_ter ^ ^ ^ ^ member setLineno_ter ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc5 ^ ^ initializer BinaryOperation operator +_ter ^ ^ operandl MethodInvocation qualifier functionNode_ter ^ ^ member getAbsolutePosition_ter ^ ^ ^ ^ operandr MethodInvocation qualifier functionNode_ter ^ ^ member getLp_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc4 ^ ^ arguments MethodInvocation arguments MemberReference member loc5 ^ ^ ^ ^ member position2charno_ter ^ ^ ^ ^ member setCharno_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation arguments MemberReference member loc4 ^ ^ ^ MemberReference member loc0 ^ ^ ^ ^ member maybeSetLengthFrom_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc3 ^ ^ arguments MemberReference member loc4 ^ ^ ^ ^ member addChildToBack_ter ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc6 ^ ^ initializer MethodInvocation arguments MemberReference qualifier Token_ter ^ ^ member PARAM_LIST_ter ^ ^ ^ ^ member newNode_ter ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Name_ter ^ ^ ^ ^ declarators VariableDeclarator name loc7 ^ ^ initializer MethodInvocation qualifier functionNode_ter ^ ^ member getFunctionName_ter ^ ^ ^ ^ ^ ^ ^ IfStatement condition BinaryOperation operator !=_ter ^ ^ operandl MemberReference member loc7 ^ ^ ^ ^ operandr Literal value null_ter ^ ^ ^ ^ ^ ^ then_statement BlockStatement statements StatementExpression expression MethodInvocation qualifier loc6 ^ ^ arguments MethodInvocation qualifier loc7 ^ ^ member getLineno_ter ^ ^ ^ ^ member setLineno_ter ^ ^ ^ ^ ^ ^ ^ ^ else_statement BlockStatement statements StatementExpression expression MethodInvocation qualifier loc6 ^ ^ arguments MethodInvocation qualifier functionNode_ter ^ ^ member getLineno_ter ^ ^ ^ ^ member setLineno_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ LocalVariableDeclaration type BasicType name int_ter ^ ^ ^ ^ declarators VariableDeclarator name loc8 ^ ^ initializer BinaryOperation operator +_ter ^ ^ operandl MethodInvocation qualifier functionNode_ter ^ ^ member getLp_ter ^ ^ ^ ^ operandr MethodInvocation qualifier functionNode_ter ^ ^ member getAbsolutePosition_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc6 ^ ^ arguments MethodInvocation arguments MemberReference member loc8 ^ ^ ^ ^ member position2charno_ter ^ ^ ^ ^ member setCharno_ter ^ ^ ^ ^ ^ ForStatement control EnhancedForControl var VariableDeclaration type ReferenceType name AstNode_ter ^ ^ ^ ^ declarators VariableDeclarator name loc9 ^ ^ ^ ^ ^ ^ iterable MethodInvocation qualifier functionNode_ter ^ ^ member getParams_ter ^ ^ ^ ^ ^ ^ body BlockStatement statements StatementExpression expression MethodInvocation qualifier loc6 ^ ^ arguments MethodInvocation arguments MemberReference member loc9 ^ ^ ^ ^ member transform_ter ^ ^ ^ ^ member addChildToBack_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc3 ^ ^ arguments MemberReference member loc6 ^ ^ ^ ^ member addChildToBack_ter ^ ^ ^ ^ ^ LocalVariableDeclaration type ReferenceType name Node_ter ^ ^ ^ ^ declarators VariableDeclarator name loc10 ^ ^ initializer MethodInvocation arguments MethodInvocation qualifier functionNode_ter ^ ^ member getBody_ter ^ ^ ^ ^ member transform_ter ^ ^ ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation arguments MemberReference member loc10 ^ ^ ^ ^ member parseDirectives_ter ^ ^ ^ ^ ^ StatementExpression expression MethodInvocation qualifier loc3 ^ ^ arguments MemberReference member loc10 ^ ^ ^ ^ member addChildToBack_ter ^ ^ ^ ^ ^ ReturnStatement expression MemberReference member loc3 ^ ^ ^ ^ ^ ^ ^ ', 'prob': [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 'mode': 0, 'line': 666, 'isa': False, 'fl_score': 1}]
before@0 batch0 x: 0: root ^  ; []
stderr: Check out program version: Closure-37b..................................... OK
OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0
Running ant (export.dir.src.classes)....................................... OK

  0%|          | 0/1 [00:00<?, ?it/s]/root/projects/Recoder-bwk/run.py:527: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  tmpdepth = np.array(tmpdepth)
  0%|          | 0/1 [00:00<?, ?it/s]
Traceback (most recent call last):
  File "testDefect4j.py", line 638, in <module>
    ans = solveone(data, model)
  File "/root/projects/Recoder-bwk/run.py", line 1100, in solveone
    ans = BeamSearch((x[0], x[1], None, None, None, None, None, None, x[2], x[3]), dev_set, model, 100, args.batch_size, indexs)
  File "/root/projects/Recoder-bwk/run.py", line 541, in BeamSearch
    result = model(gVar(tmpnl), gVar(tmpnlad), gVar(tmprule), gVar(tmpruleparent), gVar(tmprulechild), gVar(tmpAd), gVar(tmptreepath), gVar(tmpnl8), gVar(tmpnl9), tmpf, tmpc, tmpindex, tmpchar, tmpindex2, rulead, antimasks, None, "test")
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/projects/Recoder-bwk/Model.py", line 127, in forward
    charEm = self.char_embedding(tmpchar.long())
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/module.py", line 541, in __call__
    result = self.forward(*input, **kwargs)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/modules/sparse.py", line 114, in forward
    self.norm_type, self.scale_grad_by_freq, self.sparse)
  File "/root/envs/recoder/lib/python3.7/site-packages/torch/nn/functional.py", line 1484, in embedding
    return torch.embedding(weight, input, padding_idx, scale_grad_by_freq, sparse)
RuntimeError: CUDA out of memory. Tried to allocate 1.19 GiB (GPU 0; 23.65 GiB total capacity; 225.06 MiB already allocated; 659.31 MiB free; 20.94 MiB cached)
