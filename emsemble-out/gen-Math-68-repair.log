stdout: StatementExpression expression MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ 
qrDecomposition();

StatementExpression expression MethodInvocation member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor();

StatementExpression expression MethodInvocation arguments MemberReference member diagR_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(diagR);

StatementExpression expression MethodInvocation arguments MemberReference member jacNorm_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(jacNorm);

StatementExpression expression MethodInvocation arguments MemberReference member beta_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(beta);

StatementExpression expression MethodInvocation arguments MemberReference member lmPar_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(lmPar);

StatementExpression expression MethodInvocation arguments MemberReference member lmDir_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(lmDir);

StatementExpression expression MethodInvocation arguments MemberReference member initialStepBoundFactor_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(initialStepBoundFactor);

StatementExpression expression MethodInvocation arguments MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(costRelativeTolerance);

StatementExpression expression MethodInvocation arguments MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(parRelativeTolerance);

StatementExpression expression MethodInvocation arguments MemberReference member orthoTolerance_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(orthoTolerance);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(100.0);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ ^ member setCostRelativeTolerance_ter ^ ^ ^ ^ ^ 
setCostRelativeTolerance(100.0);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ ^ member setParRelativeTolerance_ter ^ ^ ^ ^ ^ 
setParRelativeTolerance(100.0);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ ^ member setOrthoTolerance_ter ^ ^ ^ ^ ^ 
setOrthoTolerance(100.0);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ ^ member qTy_ter ^ ^ ^ ^ ^ 
qTy(100.0);

StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(false);

StatementExpression expression MethodInvocation arguments Literal value true_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(true);

StatementExpression expression MethodInvocation arguments Literal value 0_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(0);

StatementExpression expression MethodInvocation arguments Literal value 1.0e-10_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(1.0e-10);

StatementExpression expression MethodInvocation arguments Literal value 1_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(1);

StatementExpression expression MethodInvocation arguments Literal value 1000_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(1000);

ReturnStatement_ter ^ 
if (true) { return;
 }

StatementExpression expression MethodInvocation arguments Literal value 2_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(2);

StatementExpression expression MethodInvocation arguments Literal value null_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(null);


StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ Literal value 1.0e-10_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(100.0, 1.0e-10);

StatementExpression expression MethodInvocation arguments Literal value 100.0_ter ^ ^ ^ Literal value 100.0_ter ^ ^ ^ ^ member setInitialStepBoundFactor_ter ^ ^ ^ ^ ^ 
setInitialStepBoundFactor(100.0, 100.0);

StatementExpression expression This selectors MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ ^ ^ 
this.qrDecomposition();

StatementExpression expression Assignment expressionl MemberReference member diagR_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
diagR = 0;

StatementExpression expression Assignment expressionl MemberReference member jacNorm_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
jacNorm = 0;

StatementExpression expression Assignment expressionl MemberReference member beta_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
beta = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference member lmDir_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmDir = 0;

StatementExpression expression Assignment expressionl MemberReference member initialStepBoundFactor_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
initialStepBoundFactor = 0;

StatementExpression expression Assignment expressionl MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
costRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
parRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference member orthoTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
orthoTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value 1_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = 1;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value 2_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = 2;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value false_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = false;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value null_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = null;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value <string>_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = "null";

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal prefix_operators -_ter ^ ^ value 1_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = -1;

StatementExpression expression Assignment expressionl MemberReference qualifier diagR_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
diagR.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier jacNorm_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
jacNorm.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier beta_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
beta.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier lmPar_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier lmDir_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmDir.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier initialStepBoundFactor_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
initialStepBoundFactor.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier costRelativeTolerance_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
costRelativeTolerance.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier parRelativeTolerance_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
parRelativeTolerance.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier orthoTolerance_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
orthoTolerance.lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value MemberReference member lmPar_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = lmPar;

StatementExpression expression Assignment expressionl MemberReference qualifier diagR_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
diagR.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier jacNorm_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
jacNorm.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier beta_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
beta.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier lmPar_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier lmDir_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmDir.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier initialStepBoundFactor_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
initialStepBoundFactor.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier costRelativeTolerance_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
costRelativeTolerance.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier parRelativeTolerance_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
parRelativeTolerance.length = 0;

StatementExpression expression Assignment expressionl MemberReference qualifier orthoTolerance_ter ^ ^ member length_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
orthoTolerance.length = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal value true_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = true;

StatementExpression expression Assignment expressionl MemberReference member doOptimize_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
doOptimize = 0;

StatementExpression expression MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ 
qrDecomposition();

StatementExpression expression MethodInvocation arguments Literal value 0_ter ^ ^ ^ ^ member lmPar_ter ^ ^ ^ ^ ^ 
lmPar(0);

StatementExpression expression Assignment expressionl MemberReference member par0 ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
 = 0;


StatementExpression expression Assignment expressionl MemberReference member firstIteration_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
firstIteration = 0;


StatementExpression expression Assignment expressionl MemberReference member e_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
e = 0;

StatementExpression expression Assignment expressionl MemberReference member debug_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
debug = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member diagR_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-diagR = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member jacNorm_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-jacNorm = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member beta_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-beta = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member lmDir_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-lmDir = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member initialStepBoundFactor_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-initialStepBoundFactor = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member costRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-costRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member parRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-parRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators -_ter ^ ^ member orthoTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
-orthoTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member diagR_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!diagR = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member jacNorm_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!jacNorm = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member beta_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!beta = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member lmPar_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!lmPar = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member lmDir_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!lmDir = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member initialStepBoundFactor_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!initialStepBoundFactor = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member costRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!costRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member parRelativeTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!parRelativeTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference prefix_operators !_ter ^ ^ member orthoTolerance_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
!orthoTolerance = 0;

StatementExpression expression Assignment expressionl MemberReference member updateResidualsAndCost_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value Literal prefix_operators -_ter ^ ^ value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = -0;

StatementExpression expression Assignment expressionl MemberReference member size_ter ^ ^ ^ ^ value Literal value 0_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
size = 0;

StatementExpression expression Assignment expressionl MemberReference member lmPar_ter ^ ^ ^ ^ value BinaryOperation operator +_ter ^ ^ operandl MemberReference member lmPar_ter ^ ^ ^ ^ operandr Literal value 1_ter ^ ^ ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
lmPar = (lmPar + 1);

StatementExpression expression MethodInvocation member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost();

StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(false);

StatementExpression expression MethodInvocation arguments Literal value true_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(true);

StatementExpression expression MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ 
qrDecomposition();

StatementExpression expression MethodInvocation arguments Literal value null_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(null);

StatementExpression expression MethodInvocation arguments Literal value <string>_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian("null");

StatementExpression expression MethodInvocation member doOptimize_ter ^ ^ ^ ^ ^ 
doOptimize();


StatementExpression expression MethodInvocation arguments Literal value 0_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(0);

StatementExpression expression MethodInvocation member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian();

StatementExpression expression MethodInvocation arguments This_ter ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(this);

StatementExpression expression MethodInvocation arguments Literal value 1_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(1);

IfStatement condition MethodInvocation member updateJacobian_ter ^ ^ ^ ^ ^ 
if(updateJacobian()){


StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ Literal value false_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(false, false);

StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ Literal value true_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(false, true);

StatementExpression expression MethodInvocation arguments Literal value true_ter ^ ^ ^ Literal value false_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(true, false);

StatementExpression expression MethodInvocation member par0 ^ ^ ^ ^ ^ 
();


StatementExpression expression MethodInvocation arguments ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian();

StatementExpression expression MethodInvocation arguments MethodInvocation member updateJacobian_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(updateJacobian());

StatementExpression expression MethodInvocation member debug_ter ^ ^ ^ ^ ^ 
debug();

StatementExpression expression MethodInvocation arguments Literal value true_ter ^ ^ ^ Literal value true_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(true, true);

StatementExpression expression MethodInvocation member e_ter ^ ^ ^ ^ ^ 
e();

StatementExpression expression MethodInvocation member incrementIterationsCounter_ter ^ ^ ^ ^ ^ 
incrementIterationsCounter();

StatementExpression expression MethodInvocation arguments Literal value null_ter ^ ^ ^ Literal value false_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(null, false);

StatementExpression expression MethodInvocation arguments Literal value null_ter ^ ^ ^ Literal value null_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(null, null);

StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ Literal value null_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian(false, null);

StatementExpression expression MethodInvocation arguments Literal value <string>_ter ^ ^ ^ Literal value false_ter ^ ^ ^ ^ member updateJacobian_ter ^ ^ ^ ^ ^ 
updateJacobian("null", false);

StatementExpression expression MethodInvocation member loc0 ^ ^ ^ ^ ^ 
();



ReturnStatement expression MemberReference member objective_ter ^ ^ ^ ^ ^ 
return objective;
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, objective);
ReturnStatement expression MemberReference member diag_ter ^ ^ ^ ^ ^ 
return diag;
ReturnStatement expression MemberReference member jacNorm_ter ^ ^ ^ ^ ^ 
return jacNorm;
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member j_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, j);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, objective);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective);
ReturnStatement expression MemberReference member point_ter ^ ^ ^ ^ ^ 
return point;
ReturnStatement expression MemberReference member cols_ter ^ ^ ^ ^ ^ 
return cols;
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference selectors ArraySelector index MemberReference member j_ter ^ ^ ^ ^ ^ ^ member diag_ter ^ ^ ^ MemberReference selectors ArraySelector index MemberReference member j_ter ^ ^ ^ ^ ^ ^ member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(diag[j], jacNorm[j]);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, jacNorm);
StatementExpression expression Assignment expressionl MemberReference selectors ArraySelector index MemberReference member j_ter ^ ^ ^ ^ ^ ^ member diag_ter ^ ^ ^ ^ value MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference selectors ArraySelector index MemberReference member j_ter ^ ^ ^ ^ ^ ^ member diag_ter ^ ^ ^ MemberReference selectors ArraySelector index MemberReference member j_ter ^ ^ ^ ^ ^ ^ member jacNorm_ter ^ ^ ^ ^ member max_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
diag[j] = Math.max(diag[j], jacNorm[j]);

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair();
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, jacNorm);
StatementExpression expression Assignment expressionl MemberReference member sum_ter ^ ^ ^ ^ value BinaryOperation operator *_ter ^ ^ operandl MemberReference selectors ArraySelector index MemberReference member i_ter ^ ^ ^ ^ ^ ArraySelector index MemberReference member pj_ter ^ ^ ^ ^ ^ ^ member jacobian_ter ^ ^ ^ ^ operandr MemberReference selectors ArraySelector index MemberReference member i_ter ^ ^ ^ ^ ^ ^ member residuals_ter ^ ^ ^ ^ ^ ^ type +=_ter ^ ^ ^ ^ ^ 
sum += (jacobian[i].[pj] * residuals[i]);


ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, diag);
StatementExpression expression Assignment expressionl MemberReference member maxCosine_ter ^ ^ ^ ^ value MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member maxCosine_ter ^ ^ ^ BinaryOperation operator /_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member sum_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member s_ter ^ ^ ^ ^ operandr MemberReference member cost_ter ^ ^ ^ ^ ^ ^ ^ ^ member max_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
maxCosine = Math.max(maxCosine, (Math.abs(sum) / (s * cost)));

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, objective, objective);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member diag_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(diag, objective);
ReturnStatement expression Literal value null_ter ^ ^ ^ ^ ^ 
return null;
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member jacNorm_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(jacNorm, objective);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member jacNorm_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(jacNorm, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member diag_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(diag, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member cols_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, cols);
BreakStatement_ter ^ 
break;

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, objective, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member jacNorm_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(jacNorm, jacNorm);
StatementExpression expression MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ 
qrDecomposition();

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(jacNorm);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member j_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(j, objective);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member diag_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(diag, jacNorm);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, objective, jacNorm);
IfStatement condition BinaryOperation operator <=_ter ^ ^ operandl MemberReference member maxCosine_ter ^ ^ ^ ^ operandr MemberReference member orthoTolerance_ter ^ ^ ^ ^ ^ ^ ^ 
if((maxCosine <= orthoTolerance)){

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member cols_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, cols);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member i_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, i);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member loc7 ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, );

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member cols_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(cols, objective);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member s_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, s);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member cols_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(cols, jacNorm);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member cols_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(cols, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ MemberReference member cols_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, objective, cols);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member cols_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(cols);
ReturnStatement expression MemberReference member cost_ter ^ ^ ^ ^ ^ 
return cost;
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member point_ter ^ ^ ^ MemberReference member maxCosine_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(point, maxCosine);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, diag, objective);
ReturnStatement expression MemberReference member maxCosine_ter ^ ^ ^ ^ ^ 
return maxCosine;
ContinueStatement_ter ^ 
continue;

ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, jacNorm, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ MemberReference member diag_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, diag, diag);
ReturnStatement expression ClassCreator type ReferenceType name VectorialPointValuePair_ter ^ ^ ^ ^ arguments MemberReference member objective_ter ^ ^ ^ MemberReference member jacNorm_ter ^ ^ ^ MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ 
arg 
arg 
return new VectorialPointValuePair(objective, jacNorm, objective);
StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(false);

StatementExpression expression MethodInvocation arguments Literal value true_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(true);

StatementExpression expression MethodInvocation arguments Literal prefix_operators -_ter ^ ^ value 1.0_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(-1.0);

StatementExpression expression MethodInvocation member doOptimize_ter ^ ^ ^ ^ ^ 
doOptimize();

StatementExpression expression MethodInvocation arguments MemberReference member delta_ter ^ ^ ^ MemberReference member lmNorm_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(delta, lmNorm);

StatementExpression expression MethodInvocation member qrDecomposition_ter ^ ^ ^ ^ ^ 
qrDecomposition();

StatementExpression expression MethodInvocation arguments This_ter ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(this);


StatementExpression expression MethodInvocation arguments MethodInvocation member updateResidualsAndCost_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(updateResidualsAndCost());

StatementExpression expression MethodInvocation arguments Literal value 0_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(0);

StatementExpression expression MethodInvocation arguments Literal value 1_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(1);

IfStatement condition MethodInvocation member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
if(updateResidualsAndCost()){


StatementExpression expression MethodInvocation arguments MemberReference member delta_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(delta);

StatementExpression expression MethodInvocation arguments MemberReference member lmNorm_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(lmNorm);

StatementExpression expression MethodInvocation member min_ter ^ ^ ^ ^ ^ 
min();

StatementExpression expression MethodInvocation arguments Literal value null_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(null);

StatementExpression expression MethodInvocation member debug_ter ^ ^ ^ ^ ^ 
debug();

StatementExpression expression MethodInvocation qualifier Math_ter ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
Math.updateResidualsAndCost();

StatementExpression expression MethodInvocation arguments Literal value <string>_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost("null");

StatementExpression expression MethodInvocation member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost();

StatementExpression expression SuperMethodInvocation member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
super.updateResidualsAndCost();

StatementExpression expression Assignment expressionl MemberReference member delta_ter ^ ^ ^ ^ value MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member delta_ter ^ ^ ^ MemberReference member lmNorm_ter ^ ^ ^ ^ member min_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
delta = Math.min(delta, lmNorm);

ReturnStatement_ter ^ 
if (true) { return;
 }

StatementExpression expression Assignment expressionl MemberReference member delta_ter ^ ^ ^ ^ value MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member delta_ter ^ ^ ^ MemberReference member lmNorm_ter ^ ^ ^ ^ member min_ter ^ ^ ^ ^ type =_ter ^ ^ ^ ^ ^ 
delta = Math.min(delta, lmNorm);

StatementExpression expression MethodInvocation arguments Literal value false_ter ^ ^ ^ Literal value false_ter ^ ^ ^ ^ member updateResidualsAndCost_ter ^ ^ ^ ^ ^ 
updateResidualsAndCost(false, false);

IfStatement condition MemberReference member firstIteration_ter ^ ^ ^ ^ ^ 
if(firstIteration){


BreakStatement_ter ^ 
break;

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta < (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta > (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio >= 2.0)) || (delta <= (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0))){

condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) && (delta <= (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator ||_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta || (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member diagR_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (diagR * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member jacNorm_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (jacNorm * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member beta_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (beta * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member lmPar_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (lmPar * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member lmDir_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (lmDir * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member initialStepBoundFactor_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (initialStepBoundFactor * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (costRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member orthoTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (orthoTolerance * xNorm)))){
IfStatement condition BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((delta <= (parRelativeTolerance * xNorm))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator &&_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta && (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator >=_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance >= xNorm)))){
IfStatement condition BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ 
if((Math.abs(actRed) <= costRelativeTolerance)){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance <= xNorm)))){
IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) || (delta <= (parRelativeTolerance * xNorm)))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator >_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance > xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member actRed_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (actRed * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member objective_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (objective * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member point_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (point * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member actRed_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * actRed)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (preRed * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator <_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance < xNorm)))){
IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) || (delta <= (parRelativeTolerance * xNorm)))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member point_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * point)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member objective_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * objective)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator ==_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta == (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) && (delta <= (parRelativeTolerance * xNorm)))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member preRed_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * preRed)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * costRelativeTolerance)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * parRelativeTolerance)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member xNorm_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (xNorm * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (delta * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member delta_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * delta)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member orthoTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * orthoTolerance)))){
IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (delta <= (parRelativeTolerance * xNorm)))){

IfStatement condition BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ 
if((preRed <= costRelativeTolerance)){

IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((Math.abs(actRed) <= costRelativeTolerance) || (delta <= (parRelativeTolerance * xNorm)))){

IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) && (delta <= (parRelativeTolerance * xNorm)))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator !=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta != (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) || (delta <= (parRelativeTolerance * xNorm))) || (delta <= (parRelativeTolerance * xNorm)))){

IfStatement condition BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((Math.abs(actRed) <= costRelativeTolerance) && (delta <= (parRelativeTolerance * xNorm)))){

IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) || (delta <= (parRelativeTolerance * xNorm))) || (delta <= (parRelativeTolerance * xNorm)))){

IfStatement condition BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ 
if((ratio <= 2.0)){

IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) || (ratio <= 2.0))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator ==_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance == xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator |_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta | (parRelativeTolerance * xNorm)))){
condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator -_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta - (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((Math.abs(actRed) <= costRelativeTolerance) || (ratio <= 2.0))){

IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) || (preRed <= costRelativeTolerance))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member doOptimize_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.doOptimize(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm)))){
IfStatement condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm)))){

condition BinaryOperation operator ||_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator &&_ter ^ ^ operandl BinaryOperation operator <=_ter ^ ^ operandl MethodInvocation qualifier Math_ter ^ ^ arguments MemberReference member actRed_ter ^ ^ ^ ^ member abs_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member preRed_ter ^ ^ ^ ^ operandr MemberReference member costRelativeTolerance_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator &_ter ^ ^ operandl MemberReference member ratio_ter ^ ^ ^ ^ operandr Literal value 2.0_ter ^ ^ ^ ^ ^ ^ ^ ^ operandr BinaryOperation operator <=_ter ^ ^ operandl MemberReference member delta_ter ^ ^ ^ ^ operandr BinaryOperation operator *_ter ^ ^ operandl MemberReference member parRelativeTolerance_ter ^ ^ ^ ^ operandr MemberReference member xNorm_ter ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
if(((((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio & 2.0)) || (delta <= (parRelativeTolerance * xNorm)))){
stderr: 